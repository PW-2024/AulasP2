{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MCTW - Projeto web","text":""},{"location":"#welcome-to-mctw-projeto-web","title":"Welcome to MCTW - Projeto web!","text":"<p>This is a collaborative documentation project where we aim to provide comprehensive documentation for the MCTW - Projeto web. All the contents of the classes will be available here, as well as the projects and exercises.</p> <p>Each student is free to contribute to the documentation by submitting a pull request! Idea is to have a single place where we can find all the information about the classes and share our knowledge.</p>"},{"location":"sprint01/","title":"Sprint goals","text":"<ul> <li> Understand and deepen knowledge in different database models;</li> <li> Define which of the models is more suitable for the project's requirements/functionalities. In some projects it may be appropriate to opt for more than one database model;</li> <li> Define a logical/physical model for the project's database;</li> <li> Create the database and execute some test queries.</li> </ul>"},{"location":"sprint01/databases/","title":"Indroduction to databases","text":""},{"location":"sprint01/databases/#what-is-a-database","title":"What is a database?","text":"<p>A database is a collection of information that is organized so that it can be easily accessed, managed, and updated. It serves as a structured repository for storing and retrieving data. Databases can be classified into different types based on the nature of the content they hold, such as bibliographic, full-text, numeric, and images. Databases exist on the phyical world and on the digital world. For example, a library has a database of books, a company has a database of employees, and a school has a database of students.</p> <p></p> <p>A library is an example of a real-world database. It typically has a database of books, where information such as book titles, authors, and availability are stored and managed.</p>"},{"location":"sprint01/databases/#what-is-a-database-management-system-dbms","title":"What is a database management system (DBMS)?","text":"<p>In the context of websites and applications, when people refer to a \u201cdatabase\u201d they\u2019re often talking about a computer program that allows them to interact with their database. These programs, known more formally as a database management system (DBMS).</p> <p>A database management system (DBMS) is system software for creating and managing databases. The DBMS provides users and programmers with a systematic way to create, retrieve, update and manage data.</p> <p>Examples of DBMS: - MySQL - PostgreSQL - MongoDB - Neo4j</p>"},{"location":"sprint01/databases/#how-do-we-interact-with-a-dbms","title":"How do we interact with a DBMS?","text":"<p>The DBMS accepts requests for data from an application program and instructs the operating system to transfer the appropriate data. The DBMS receives the data from the operating system and instructs it to transfer the data to the application.</p> <p>Example of a simple interaction with a DBMS (using SQL):</p> <pre><code>SELECT * FROM employees WHERE salary &gt; 50000;\n</code></pre> <p>In this example, the DBMS is instructed to retrieve all the records from the employees table where the salary is greater than 50000.</p>"},{"location":"sprint01/databases/#what-is-a-database-model","title":"What is a database model?","text":"<p>A database model is a type of data model that determines the logical structure of a database and fundamentally determines in which manner data can be stored, organized, and manipulated.</p>"},{"location":"sprint01/databases/#types-of-database-models-in-web-development","title":"Types of database models in web development:","text":""},{"location":"sprint01/databases/#relational-databases","title":"Relational databases","text":"<p>Relational databases are a cornerstone of traditional database management systems, characterized by their structured approach to organizing data. At the heart of a relational database is the relational model, which was introduced by Edgar F. Codd in 1970. This model organizes data into one or more tables (or \"relations\") of rows and columns, with a unique key identifying each row. Rows in the table represent data entries, and columns represent the attributes of the data.</p> <p></p>"},{"location":"sprint01/databases/#nosql-databases","title":"NoSQL databases","text":"<p>A NoSQL (originally referring to \"non SQL\" or \"non relational\") database provides a mechanism for storage and retrieval of data that is modeled in means other than the tabular relations used in relational databases. Actually the term \"non SQL\" has been redefined to \"not only SQL\" to emphasize that they may support SQL-like query languages even though they may not be SQL-based.</p>"},{"location":"sprint01/databases/#common-types-of-nosql-databases-include","title":"Common types of NoSQL databases include:","text":""},{"location":"sprint01/databases/#document-databases","title":"Document databases","text":"<p>A document-oriented database, or document store, is a computer program and data storage system designed for storing, retrieving, and managing document-oriented information, also known as semi-structured data. This type of database adds the concept of a document, which encapsulates and stores data in a standard format such as JSON or XML. Each document contains one or more fields, including arrays, binary data, or sub-documents. Fields can vary from document to document, and the data structure can be changed over time.</p> <p>Example: MongoDB</p> <p></p>"},{"location":"sprint01/databases/#key-value-databases","title":"Key-value databases","text":"<p>A key-value database, or key-value store, is a data storage paradigm designed for storing, retrieving, and managing associative arrays, and a data structure more commonly known today as a dictionary or hash table. This type of databases are commonly used for caching, session management, and real-time analytics. They are also used in applications that require high-speed data access.</p> <p>Example: Redis</p>"},{"location":"sprint01/databases/#graph-databases","title":"Graph databases","text":"<p>A graph database is a database that uses graph structures for semantic queries with nodes, edges, and properties to represent and store data. A key concept of the system is the graph (or edge or relationship), which directly relates data items in the store. The relationships allow data in the store to be linked together directly, and in many cases retrieved with one operation. This type of database is well-suited for applications that require complex queries and deep relationships between data entities.</p> <p>Example: Neo4j</p>"},{"location":"sprint01/databases/#columnar-databases","title":"Columnar databases","text":"<p>A columnar database is a database management system (DBMS) that stores data in columns rather than in rows. This type of database is designed to efficiently store and retrieve data for data warehousing and analytics applications. It is particularly well-suited for read-heavy workloads, such as business intelligence and data warehousing.</p> <p>Example: Cassandra</p>"},{"location":"sprint01/databases/#choosing-the-right-database-model","title":"Choosing the right database model","text":"<p>Very often, the choice of a database model is not a simple one. It might depend on the nature of the data, the requirements of the application, and the skills of the development team.</p> <p></p> <p>Dispite the fact that NoSQL databases are gaining popularity, relational databases are still the most widely used database model. This is because they are well-established, and the skills to work with them are widely available. However, NoSQL databases are gaining popularity because they are often more scalable and flexible than relational databases.</p> <p>Each type of database model has its own strengths and weaknesses, and the choice of a database model should be made based on the specific requirements of the application and again the knowledge of the development team as in the end, the database model is just a tool to solve a problem.</p>"},{"location":"sprint01/databases/#the-campus-by-fundacao-altice-example","title":"The Campus by Funda\u00e7\u00e3o Altice example","text":"<p>Campus by Funda\u00e7\u00e3o Altice is a social web application that allows students to connect with each other. As it's social nature, it has different types of features like user profiles, posts, comments, favorites, chat, images, and videos:</p> <p></p>"},{"location":"sprint01/databases/#what-dabase-model-would-you-choose-for-campus","title":"What dabase model would you choose for Campus?","text":"<p>As Campus by Funda\u00e7\u00e3o Altice has the social nature and different kinds of features and requirements, it ended up using different databases in order to solve different problems:</p> <ul> <li> <p>Social nature of the application - Graph database (Neo4j) - to solve the complex relationships between users network and the posts, comments, favorites, ...</p> </li> <li> <p>Authentication and user profiles - Relational database (MySQL) - to solve the structured nature of the user profiles and the authentication process.</p> </li> <li> <p>Chat - Elasticsearch - to solve the real-time nature of the chat and the search of messages efficiently.</p> </li> <li> <p>Notifications - MongoDB - to solve the semi-structured nature of the notifications and the real-time nature of the notifications.</p> </li> <li> <p>Session tokens - Redis - as the session tokens are a non sensitive information that expires after a short period of time and needs to be accessed quickly.</p> </li> </ul> <p></p>"},{"location":"sprint01/databases/model/","title":"Small guide for data modeling","text":""},{"location":"sprint01/databases/model/#what-is-data-modeling","title":"What is Data Modeling?","text":"<p>Data model is the process of turning your application features and requirements into a database properly schema. Data models provide a blueprint for designing a new database or reengineering a legacy application. Overall, data modeling helps an organization use its data effectively to meet business needs for information.</p>"},{"location":"sprint01/databases/model/#why-is-data-modeling-important","title":"Why is Data Modeling important?","text":"<p>The essence of data modeling lies in its capacity to elucidate data attributes, their interconnections, and the overarching structure. It plays a crucial role in demystifying business operations and the informational prerequisites of the application. Through data modeling, critical data requirements are identified and strategized for optimal organization.</p> <p>Data modeling makes it easier for developers, data architects, business analysts, and other stakeholders to view and understand relationships among the data in a database. In addition, it can:</p> <ul> <li>Reduce errors in software and database development.</li> <li>Improve application and database performance.</li> <li>Ease in Data Analysis and Decision Making</li> <li>Better Data Integrity and Consistency</li> <li>Ease and speed the process of database design at the conceptual, logical and physical levels.</li> </ul>"},{"location":"sprint01/databases/model/#steps-to-data-modeling","title":"Steps to Data Modeling","text":""},{"location":"sprint01/databases/model/#conceptual-data-model","title":"Conceptual Data Model","text":"<p>The conceptual data model identifies the highest-level relationships between different entities. It is a high-level data model that defines what the system contains. It is independent of hardware or software constraints. It is a representation of organizational data requirements at a high level that is independent of the database management system (DBMS) that will be used to implement the database.</p> <p>Some developers skip this step and go directly to the logical data model, but it is important to understand the business requirements and the entities that will be part of the database. Going directly to the logical data model can lead to a database that does not meet the business requirements. Or, sometimes, it might lead to an over-engineered database that is too complex for the business requirements that might often be simple.</p> <p></p>"},{"location":"sprint01/databases/model/#logical-data-model","title":"Logical Data Model","text":"<p>The logical data model is a detailed version of the conceptual data model. It is a high-level data model that is independent of the database management system and other physical considerations. It is a representation of the data that is independent of any application that will use the data. The logical data model is used to define the structure of the data elements and to set relationships between them.</p> <p></p>"},{"location":"sprint01/databases/model/#physical-data-model","title":"Physical Data Model","text":"<p>The physical data model is a detailed version of the logical data model. It is a low-level data model that is used to organize data on a storage medium. It defines the logical structure of the database and provides the basis for the development of the physical database. It is a representation of the data that is used in the database and that is independent of the database management system.</p> <p>Depending on the type of the database the physical data model can be different. For example, for a relational database, the physical data model is a representation of the actual database. For a NoSQL database, the physical data model is a representation of the data that is used in the database and that is independent of the database management system.</p>"},{"location":"sprint01/databases/model/#relational-database","title":"Relational Database","text":""},{"location":"sprint01/databases/model/#document-database","title":"Document Database","text":""},{"location":"sprint01/databases/model/#graph-database","title":"Graph Database","text":""},{"location":"sprint01/resources/choose-a-db/","title":"Choose a DB","text":"<p>The following diagram helps you to choose the right database for your project, or specific application feature:</p> <p></p>"},{"location":"sprint01/types-of-databases/Mongo/","title":"MongoDB","text":""},{"location":"sprint01/types-of-databases/Mongo/#what-is-mongodb","title":"What is MongoDB?","text":"<p>MongoDB is a cross-platform document-oriented database program. Classified as a NoSQL database program, MongoDB uses JSON-like documents with optional schemas.</p>"},{"location":"sprint01/types-of-databases/Mongo/#what-is-a-document","title":"What is a document?","text":"<p>A record in a MongoDB collection is a document, which is a data structure composed of field and value pairs. MongoDB documents are similar to JSON objects. The values of fields may include other documents, arrays, and arrays of documents.</p>"},{"location":"sprint01/types-of-databases/Mongo/#what-is-a-collection","title":"What is a collection?","text":"<p>A collection is a grouping of MongoDB documents. A collection is the equivalent of an RDBMS table. A collection exists within a single database. Collections do not enforce a schema. Documents within a collection can have different fields. Typically, all documents in a collection are of similar or related purpose.</p>"},{"location":"sprint01/types-of-databases/Mongo/#mongodb-crud-operations","title":"MongoDB CRUD Operations","text":""},{"location":"sprint01/types-of-databases/Mongo/#create","title":"Create","text":"<p>The insert() method is used to insert documents into a collection.</p> <pre><code>db.users.insert({\n    name: \"John\",\n    age: 25,\n})\n</code></pre>"},{"location":"sprint01/types-of-databases/Mongo/#read","title":"Read","text":"<p>The find() method is used to query documents in a collection.</p> <pre><code>db.collection('users').find({\n    name: \"John\"\n})\n</code></pre>"},{"location":"sprint01/types-of-databases/Mongo/#update","title":"Update","text":"<p>The update() method is used to update documents in a collection.</p> <pre><code>db.collection('users').update(\n    { name: \"John\" },\n    { $set: { age: 26 } }\n)\n</code></pre>"},{"location":"sprint01/types-of-databases/Mongo/#delete","title":"Delete","text":"<p>The remove() method is used to delete documents from a collection.</p> <pre><code>db.collection('users').remove({ name: \"John\" })\n</code></pre>"},{"location":"sprint01/types-of-databases/Mongo/#mongodb-indexes","title":"MongoDB Indexes","text":"<p>Indexes are used to retrieve data from the database more quickly than otherwise. The users cannot see the indexes, they are just used to speed up searches/queries.</p> <pre><code>db.collection('users').createIndex( { name: 1 } )\n</code></pre> <pre><code>db.collection('users').createIndex( { name: 1, age: -1 } )\n</code></pre> <p>Difference between 1 and -1: 1 is for ascending and -1 is for descending.</p>"},{"location":"sprint01/types-of-databases/Mongo/#mongodb-aggregation","title":"MongoDB Aggregation","text":"<p>Aggregation operations process data records and return computed results. Aggregation operations group values from multiple documents together, and can perform a variety of operations on the grouped data to return a single result.</p> <pre><code>db.collection('users').aggregate([\n    { $group: { _id: \"$name\", total: { $sum: \"$age\" } } }\n])\n</code></pre>"},{"location":"sprint01/types-of-databases/Mongo/#schema-less-but","title":"Schema less but...","text":""},{"location":"sprint01/types-of-databases/Mongo/#defining-a-mongo-collection-schema","title":"Defining a mongo collection schema","text":"<pre><code>const mongoose = require('mongoose');\n\nconst userSchema = new mongoose.Schema({\n  name: {\n    type: String,\n    required: true\n  },\n  age: {\n    type: Number,\n    required: true\n  }\n});\n\nmodule.exports = mongoose.model('User', userSchema);\n</code></pre>"},{"location":"sprint01/types-of-databases/Mongo/#mongodb-data-modeling","title":"MongoDB Data Modeling","text":"<p>Data in MongoDB has a flexible schema. Collections do not enforce a schema. If you insert a document into a collection that does not exist, MongoDB will create the collection for you.</p>"},{"location":"sprint01/types-of-databases/Mongo/#common-modeling-patterns","title":"Common modeling patterns","text":"<ul> <li>Document Versioning</li> <li>Polymorphic Pattern</li> <li>Attribute Pattern</li> <li>Bucket Pattern</li> <li>Outlier Pattern</li> <li>Computed Pattern</li> <li>Subset Pattern</li> <li>Approximation Pattern</li> </ul>"},{"location":"sprint01/types-of-databases/Mongo/#mongodb-transactions","title":"MongoDB Transactions","text":"<p>In MongoDB, an operation on a single document is atomic. Because you can use embedded documents and arrays to capture relationships between data in a single document structure instead of normalizing across multiple documents and collections, this single-document atomicity obviates the need for distributed transactions for many practical use cases.</p> <pre><code> // For a replica set, include the replica set name and a seedlist of the members in the URI string; e.g.\n  // const uri = 'mongodb://mongodb0.example.com:27017,mongodb1.example.com:27017/?replicaSet=myRepl'\n  // For a sharded cluster, connect to the mongos instances; e.g.\n  // const uri = 'mongodb://mongos0.example.com:27017,mongos1.example.com:27017/'\n  const client = new MongoClient(uri);\n  await client.connect();\n  // Prereq: Create collections.\n  await client\n    .db('mydb1')\n    .collection('foo')\n    .insertOne({ abc: 0 }, { writeConcern: { w: 'majority' } });\n  await client\n    .db('mydb2')\n    .collection('bar')\n    .insertOne({ xyz: 0 }, { writeConcern: { w: 'majority' } });\n  // Step 1: Start a Client Session\n  const session = client.startSession();\n  // Step 2: Optional. Define options to use for the transaction\n  const transactionOptions = {\n    readPreference: 'primary',\n    readConcern: { level: 'local' },\n    writeConcern: { w: 'majority' }\n  };\n  // Step 3: Use withTransaction to start a transaction, execute the callback, and commit (or abort on error)\n  // Note: The callback for withTransaction MUST be async and/or return a Promise.\n  try {\n    await session.withTransaction(async () =&gt; {\n      const coll1 = client.db('mydb1').collection('foo');\n      const coll2 = client.db('mydb2').collection('bar');\n      // Important:: You must pass the session to the operations\n      await coll1.insertOne({ abc: 1 }, { session });\n      await coll2.insertOne({ xyz: 999 }, { session });\n    }, transactionOptions);\n  } finally {\n    await session.endSession();\n    await client.close();\n  }\n</code></pre>"},{"location":"sprint01/types-of-databases/Mongo/#data-modeling-specifics","title":"Data Modeling Specifics","text":"<p>Data in MongoDB has a flexible schema model, which means:</p> <ul> <li> <p>Documents within a single collection are not required to have the same set of fields.</p> </li> <li> <p>A field's data type can differ between documents within a collection.</p> </li> </ul>"},{"location":"sprint01/types-of-databases/Mongo/#schema-design-process","title":"Schema Design Process","text":"<p>The schema design process helps you prepare an effective schema for your application. Following the schema design process helps you identify what data your application needs and how to best organize your data to optimize performance.</p> <p>Steps to design a schema:</p>"},{"location":"sprint01/types-of-databases/Mongo/#identify-application-workload","title":"Identify Application Workload","text":"<ol> <li> <p>Identify the application\u2019s needs: </p> <ul> <li>What are the most common operations performed by the application?</li> <li>What are the most common read and write patterns?</li> <li>What are the most common aggregation operations?</li> </ul> </li> <li> <p>Create a workload table with your application's queries</p> </li> </ol>"},{"location":"sprint01/types-of-databases/Mongo/#map-schema-relationships","title":"Map Schema Relationships","text":"<p>Decide how to model relationships between entities. Embed or reference? Or both with data duplication? </p> <ol> <li> <p>Identify related data in your schema - Identify the data that your application queries and how entities relate to each other based on your workload table.</p> </li> <li> <p>Create a schema map for your related data - Your schema map should show related data fields and the type of relationship between those fields (one-to-one, one-to-many, many-to-many). (ERD model)</p> </li> <li> <p>Choose whether to embed related data or use references</p> </li> </ol>"},{"location":"sprint01/types-of-databases/Mongo/#apply-schema-design-patterns","title":"Apply Schema Design Patterns","text":"<ol> <li>subset pattern - duplicated data</li> <li>computed pattern - calculated data</li> <li>bucket pattern - grouping data</li> </ol>"},{"location":"sprint01/types-of-databases/Neo4j/","title":"Neo4j","text":"<p>Neo4j is a graph database management system developed by Neo4j, Inc. It is an open-source NoSQL graph database implemented in Java and Scala. The developers describe Neo4j as \"embedded, disk-based, fully transactional Java persistence engine that stores data structured in graphs rather than in tables\".</p>"},{"location":"sprint01/types-of-databases/Neo4j/#neo4j-architecture","title":"Neo4j Architecture","text":"<p>Neo4j's architecture is designed around the principles of graph theory, allowing for efficient representation and querying of complex networks of data. The core components include:</p> <p>Store Files: Neo4j uses store files to persist graph data on disk. These files include nodes, relationships, properties, and indexes. Transaction Log: For durability and consistency, Neo4j maintains a transaction log that records all changes to the database. Caching: Neo4j uses memory caching to improve performance by keeping frequently accessed data in memory. Clustering: Neo4j supports a clustered architecture through the use of Neo4j Fabric, which allows for scaling out and high availability.</p>"},{"location":"sprint01/types-of-databases/Neo4j/#graph-theory-basics","title":"Graph Theory Basics","text":"<p>Understanding graph theory is crucial for working with Neo4j. Key concepts include:</p> <ul> <li>Node: The fundamental entity in a graph, representing objects such as people, products, or concepts. Relationship: Connects nodes, representing how entities are related. Relationships in Neo4j are always directional and typed.</li> <li>Label: Used to group nodes into categories, making it easier to apply constraints and perform queries.</li> <li>Property: Key-value pairs attached to nodes and relationships, providing additional information about graph elements.</li> </ul>"},{"location":"sprint01/types-of-databases/Neo4j/#cypher-query-language","title":"Cypher Query Language","text":"<p>Cypher is a declarative graph query language that allows for expressive and efficient querying and manipulation of graph data. Key features include:</p> <ul> <li>Pattern Matching: Allows for expressing complex graph patterns that Neo4j will match against its graph database.</li> <li>Filtering: Cypher provides various ways to filter query results, including WHERE clauses and functions.</li> <li>Aggregation: Similar to SQL, Cypher supports aggregation functions to summarize data, such as COUNT, AVG, MAX, and MIN.</li> </ul>"},{"location":"sprint01/types-of-databases/Neo4j/#neo4j-crud-operations","title":"Neo4j CRUD Operations","text":""},{"location":"sprint01/types-of-databases/Neo4j/#create","title":"Create","text":"<p>The CREATE clause is used to create nodes and relationships in the graph.</p> <pre><code>CREATE (n:Person { name: 'John' })\n</code></pre> <pre><code>CREATE (n:Person { name: 'John' })-[:FRIEND]-&gt;(m:Person { name: 'Jane' })\n</code></pre>"},{"location":"sprint01/types-of-databases/Neo4j/#read","title":"Read","text":"<p>The MATCH clause is used to query nodes and relationships in the graph.</p> <pre><code>MATCH (n:Person:Active { name: 'John' })\n</code></pre> <pre><code>MATCH (n:Person { name: 'John' })-[:FRIEND]-&gt;(m:Person)\n</code></pre>"},{"location":"sprint01/types-of-databases/Neo4j/#update","title":"Update","text":"<p>The SET clause is used to update nodes and relationships in the graph.</p> <pre><code>MATCH (n:Person { name: 'John' })\nSET n.age = 26\nSET n:Active\n</code></pre>"},{"location":"sprint01/types-of-databases/Neo4j/#delete","title":"Delete","text":"<p>The DELETE clause is used to delete nodes and relationships in the graph.</p> <pre><code>MATCH (n:Person { name: 'John' })\nDELETE n\n</code></pre>"},{"location":"sprint01/types-of-databases/Neo4j/#neo4j-indexes","title":"Neo4j Indexes","text":"<p>Indexes are used to retrieve data from the database more quickly than otherwise. The users cannot see the indexes, they are just used to speed up searches/queries.</p> <pre><code>CREATE INDEX ON :Person(name)\n</code></pre> <pre><code>CREATE INDEX ON :Person(name, age)\n</code></pre>"},{"location":"sprint01/types-of-databases/Redis/","title":"Redis","text":"<p>Redis is key-value database. It is an open-source, in-memory data structure store, used as a database, cache, and message broker.</p> <p>It is commonly used for caching, real-time analytics, messaging, and queuing.</p>"},{"location":"sprint01/types-of-databases/Redis/#redis-data-types","title":"Redis Data Types","text":"<p>Redis supports different kinds of data types:</p> <ul> <li> <p>Strings: The most basic type of Redis value. Redis Strings are binary safe, meaning they can contain any kind of data, e.g., a JPEG image or a serialized Ruby object.</p> </li> <li> <p>Lists: A collection of string elements sorted according to the order of insertion. They are essentially linked lists, which means that even if you have millions of elements, adding a new element at the head or tail of the list is a constant-time operation.</p> </li> <li> <p>Sets: An unordered collection of strings that allows you to add, remove, and test for the existence of members in O(1) time complexity.</p> </li> <li> <p>Sorted Sets: Similar to Sets but with a score associated with each element, allowing them to be sorted from the smallest to the greatest score.</p> </li> <li> <p>Hashes: A collection of key-value pairs, perfect for representing objects.</p> </li> <li> <p>Bitmaps and HyperLogLogs: These are specialized data types for counting unique elements in a set or for probabilistic counting functions.</p> </li> <li> <p>Streams: A data type introduced in Redis 5.0, which is a log-like data structure that provides append-only semantics for sequences of messages.</p> </li> </ul>"},{"location":"sprint01/types-of-databases/Redis/#redis-commands","title":"Redis Commands","text":"<p>Redis commands are used to interact with the data stored in Redis. Here's a look at some basic commands for each Redis data type:</p>"},{"location":"sprint01/types-of-databases/Redis/#strings","title":"Strings","text":"<pre><code>SET key value\nGET key\n</code></pre>"},{"location":"sprint01/types-of-databases/Redis/#lists","title":"Lists","text":"<pre><code>LPUSH key value\nRPUSH key value\nLPOP key\n</code></pre>"},{"location":"sprint01/types-of-databases/Redis/#sets","title":"Sets","text":"<pre><code>SADD key member\nSMEMBERS key\nSISMEMBER key member\n</code></pre>"},{"location":"sprint01/types-of-databases/Redis/#sorted-sets","title":"Sorted Sets","text":"<pre><code>ZADD key score member\nZRANGE key start stop [WITHSCORES]\n</code></pre>"},{"location":"sprint01/types-of-databases/Redis/#hashes","title":"Hashes","text":"<pre><code>HSET key field value\nHGET key field\n</code></pre>"},{"location":"sprint01/types-of-databases/Redis/#keys","title":"Keys","text":"<pre><code>DEL key\nEXISTS key\n</code></pre>"},{"location":"sprint01/types-of-databases/Redis/#redis-persistence","title":"Redis Persistence","text":"<p>Redis offers a range of persistence options:</p>"},{"location":"sprint01/types-of-databases/Redis/#rdb-redis-database","title":"RDB (Redis Database):","text":"<p>The RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</p>"},{"location":"sprint01/types-of-databases/Redis/#aof-append-only-file","title":"AOF (Append Only File):","text":"<p>The AOF persistence logs every write operation received by the server, that will be played again at server startup, reconstructing the original dataset.</p>"},{"location":"sprint01/types-of-databases/Redis/#redis-transactions","title":"Redis Transactions","text":"<p>Redis transactions allow the execution of a group of commands in a single step, with two important guarantees: All the commands in a transaction are serialized and executed sequentially. A Redis transaction is atomic, which means that either all of the commands or none are processed.</p>"},{"location":"sprint01/types-of-databases/Redis/#redis-pubsub","title":"Redis Pub/Sub","text":"<p>Redis Pub/Sub is a messaging pattern where senders (publishers) do not send messages directly to receivers (subscribers). Instead, published messages are characterized into channels without knowledge of what (if any) subscribers there may be.</p>"},{"location":"sprint01/types-of-databases/Redis/#redis-security","title":"Redis Security","text":"<p>Redis includes a few security features such as command renaming and disabling, and basic authentication. Redis does not support encryption.</p>"},{"location":"sprint01/types-of-databases/Redis/#redis-clustering","title":"Redis Clustering","text":"<p>Redis Cluster provides a way to run a Redis installation where data is automatically sharded across multiple Redis nodes. It provides high availability and scalability.</p>"},{"location":"sprint01/types-of-databases/Redis/#redis-sentinel","title":"Redis Sentinel","text":"<p>Redis Sentinel provides high availability for Redis. It monitors Redis instances, providing automatic failover if a master instance is not working correctly.</p> <p>Redis is known for its flexibility, performance, and wide language support. It's used in various use cases such as caching, session storage, real-time analytics, and more.</p>"},{"location":"sprint01/types-of-databases/Relational/","title":"SQL (Relational database)","text":"<p>Relational databases are the most common type of database used in web development. They are based on the relational model of data, as proposed by E. F. Codd in 1970. A software system used to maintain relational databases is a relational database management system (RDBMS).</p>"},{"location":"sprint01/types-of-databases/Relational/#examples-of-rdbms-relational-database-management-systems","title":"Examples of RDBMS - Relational Database Management Systems","text":"<ol> <li> <p>MySQL</p> </li> <li> <p>PostgreSQL</p> </li> </ol>"},{"location":"sprint01/types-of-databases/Relational/#sql-in-detail","title":"SQL in detail","text":"<p>SQL (Structured Query Language) is a domain-specific language used in programming and designed for managing data held in a relational database management system (RDBMS), or for stream processing in a relational data stream management system (RDSMS). Example: MySQL</p> <p>The following are the most common SQL commands and their usage organized by category:</p>"},{"location":"sprint01/types-of-databases/Relational/#ddl-data-definition-language","title":"DDL (Data Definition Language)","text":"<p>The SQL DDL commands are used to create, modify, and drop the structure of the database objects.</p> <pre><code>CREATE TABLE table_name (\n    column1 datatype, -- column definition, MySQL data types: https://www.w3schools.com/sql/sql_datatypes.asp\n    column2 datatype,\n    column3 datatype,\n   ....\n);\n</code></pre> <pre><code>ALTER TABLE table_name\nADD column_name datatype;\n</code></pre> <pre><code>DROP TABLE table_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#dml-data-manipulation-language","title":"DML (Data Manipulation Language)","text":"<p>The SQL DML commands are used to insert, update, and delete the data from the database. </p> <pre><code>INSERT INTO table_name (column1, column2, column3, ...)\nVALUES (value1, value2, value3, ...);\n</code></pre> <pre><code>UPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;\n</code></pre> <pre><code>DELETE FROM table_name\nWHERE condition;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#dcl-data-control-language","title":"DCL (Data Control Language)","text":"<p>The SQL DCL commands are used to grant and take back authority and privileges from the database users.</p> <pre><code>GRANT privilege_name\nON object_name\nTO {user_name | PUBLIC | role_name};\n</code></pre> <pre><code>REVOKE privilege_name\nON object_name\nFROM {user_name | PUBLIC | role_name};\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#tcl-transaction-control-language","title":"TCL (Transaction Control Language)","text":"<p>The SQL TCL commands are used to manage the changes made by DML statements. The TCL commands are auto-committed. It means changes made by TCL command are permanent to the database.</p> <pre><code>COMMIT;\n</code></pre> <pre><code>ROLLBACK;\n</code></pre> <pre><code>SAVEPOINT savepoint_name;\n</code></pre> <pre><code>ROLLBACK TO SAVEPOINT savepoint_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#sql-joins","title":"SQL Joins","text":"<p>A SQL JOIN combines records from two tables. A JOIN locates related column values in the two tables. A query can contain zero, one, or multiple JOIN operations.</p>"},{"location":"sprint01/types-of-databases/Relational/#inner-join","title":"INNER JOIN","text":"<p>The INNER JOIN keyword selects records that have matching values in both tables.</p> <pre><code>SELECT column_name(s)\nFROM table1\nINNER JOIN table2\nON table1.column_name = table2.column_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#left-join","title":"LEFT JOIN","text":"<p>The LEFT JOIN keyword returns all records from the left table (table1), and the matched records from the right table (table2). The result is NULL from the right side if there is no match.</p> <pre><code>SELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name = table2.column_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#right-join","title":"RIGHT JOIN","text":"<p>The RIGHT JOIN keyword returns all records from the right table (table2), and the matched records from the left table (table1). The result is NULL from the left side when there is no match.</p> <pre><code>SELECT column_name(s)\nFROM table1\nRIGHT JOIN table2\nON table1.column_name = table2.column_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#full-join","title":"FULL JOIN","text":"<p>The FULL JOIN keyword returns all records when there is a match in either left (table1) or right (table2) table records.</p> <pre><code>SELECT column_name(s)\nFROM table1\nFULL JOIN table2\nON table1.column_name = table2.column_name\nWHERE condition;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#sql-functions","title":"SQL Functions","text":""},{"location":"sprint01/types-of-databases/Relational/#aggregate-functions","title":"Aggregate functions","text":"<p>Aggregate functions perform a calculation on a set of values and return a single value.</p> <pre><code>SELECT AVG(column_name)\nFROM table_name;\n</code></pre> <pre><code>SELECT COUNT(column_name)\nFROM table_name;\n</code></pre> <pre><code>SELECT MAX(column_name)\nFROM table_name;\n</code></pre> <pre><code>SELECT MIN(column_name)\nFROM table_name;\n</code></pre> <pre><code>SELECT SUM(column_name)\nFROM table_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#scalar-functions","title":"Scalar functions","text":"<p>Scalar functions return a single value based on the input value.</p> <pre><code>SELECT UCASE(column_name)\nFROM table_name;\n</code></pre> <pre><code>SELECT LCASE(column_name)\nFROM table_name;\n</code></pre> <pre><code>SELECT MID(column_name, start, length)\nFROM table_name;\n</code></pre> <pre><code>SELECT LEN(column_name)\nFROM table_name;\n</code></pre> <pre><code>SELECT ROUND(column_name, decimals)\nFROM table_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#sql-constraints","title":"SQL Constraints","text":"<p>Constraints are used to specify rules for the data in a table.</p>"},{"location":"sprint01/types-of-databases/Relational/#not-null","title":"NOT NULL","text":"<p>The NOT NULL constraint enforces a column to not accept NULL values.</p> <pre><code>CREATE TABLE table_name (\n    column1 datatype NOT NULL,\n    column2 datatype,\n    column3 datatype,\n   ....\n);\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#unique","title":"UNIQUE","text":"<p>The UNIQUE constraint ensures that all values in a column are different.</p> <pre><code>CREATE TABLE table_name (\n    column1 datatype UNIQUE,\n    column2 datatype,\n    column3 datatype,\n   ....\n);\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#primary-key","title":"PRIMARY KEY","text":"<p>The PRIMARY KEY constraint uniquely identifies each record in a table.</p> <pre><code>CREATE TABLE table_name (\n    column1 datatype PRIMARY KEY,\n    column2 datatype,\n    column3 datatype,\n   ....\n);\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#foreign-key","title":"FOREIGN KEY","text":"<p>The FOREIGN KEY constraint is used to prevent actions that would destroy links between tables.</p> <pre><code>CREATE TABLE table_name (\n    column1 datatype,\n    column2 datatype,\n    column3 datatype,\n    FOREIGN KEY (column1) REFERENCES another_table(column1)\n);\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#check","title":"CHECK","text":"<p>The CHECK constraint ensures that all values in a column satisfy certain conditions.</p> <pre><code>CREATE TABLE table_name (\n    column1 datatype,\n    column2 datatype,\n    column3 datatype,\n    CHECK (column1 &gt; 0)\n);\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#default","title":"DEFAULT","text":"<p>The DEFAULT constraint is used to set a default value for a column.</p> <pre><code>CREATE TABLE table_name (\n    column1 datatype DEFAULT default_value,\n    column2 datatype,\n    column3 datatype,\n   ....\n);\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#sql-indexes","title":"SQL Indexes","text":"<p>Indexes are used to retrieve data from the database more quickly than otherwise. The users cannot see the indexes, they are just used to speed up searches/queries.</p> <pre><code>CREATE INDEX index_name\nON table_name (column1, column2, ...);\n</code></pre> <pre><code>DROP INDEX table_name.index_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#sql-views","title":"SQL Views","text":"<p>A view is a virtual table based on the result-set of an SQL statement. A view contains rows and columns, just like a real table. The fields in a view are fields from one or more real tables in the database.</p> <pre><code>CREATE VIEW view_name AS\nSELECT column1, column2\nFROM table_name\nWHERE condition;\n</code></pre> <pre><code>DROP VIEW view_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#sql-triggers","title":"SQL Triggers","text":"<p>A trigger is a set of SQL statements that automatically \"fires\" when a specific event occurs in a database. Supported by: MySQL, SQL Server, PostgreSQL, and Oracle.</p> <pre><code>CREATE TRIGGER trigger_name\nBEFORE INSERT ON table_name\nFOR EACH ROW\nBEGIN\n    -- trigger code example:\n    INSERT INTO log_table VALUES (NEW.column1, 'inserted');\nEND;\n</code></pre> <pre><code>END;\n</code></pre> <pre><code>DROP TRIGGER trigger_name;\n</code></pre>"},{"location":"sprint01/types-of-databases/Relational/#sql-transactions","title":"SQL Transactions","text":"<p>A transaction is a single unit of work. If a transaction is successful, all of the data modifications made during the transaction are committed and become a permanent part of the database. If a transaction encounters errors and must be canceled or rolled back, then all of the data modifications are erased.</p> <p>Also known as ACID properties:</p> <ul> <li>Atomicity</li> <li>Consistency</li> <li>Isolation</li> <li>Durability</li> </ul> <p>Full example: <pre><code>START TRANSACTION;\nINSERT INTO table1 VALUES (1, 'a');\n-- Savepoint is used to set a point in the transaction to which you can later roll back.\nSAVEPOINT savepoint1;\nINSERT INTO table1 VALUES (2, 'b');\n-- Rollback is used to undo the changes made by the transaction and restore the database to the state before the transaction began.  Rollback is only called if the transaction is not committed.\nROLLBACK TO SAVEPOINT savepoint1;\nCOMMIT;\n</code></pre></p>"},{"location":"sprint01/types-of-databases/Relational/#modeling-techniques","title":"Modeling Techniques","text":""},{"location":"sprint01/types-of-databases/Relational/#physical-model","title":"Physical model","text":"<p>A physical data model is a representation of a data design that takes into account the facilities and constraints of a given database management system.</p>"},{"location":"sprint01/types-of-databases/Relational/#normalization","title":"Normalization","text":"<p>Normalization is a database design technique that reduces data redundancy and eliminates undesirable characteristics like Insertion, Update and Deletion Anomalies. Normalization rules simplified:</p> <ol> <li>First Normal Form</li> </ol> <p>All rows must be unique. (identified by a primary key) Each cell must contain a single value. No repeating groups or arrays. Each value should be non divisible. (atomic) firstName, lastName instead of full name</p> <ol> <li>Second Normal Form</li> </ol> <p>First Normal Form should be achieved. No partial dependencies. (no calculated fields) - example total_price = price * quantity</p> <ol> <li>Third Normal Form</li> </ol> <p>Second Normal Form should be achieved. No transitive dependencies. All fields are dependent on the primary/composite key.</p>"},{"location":"sprint01/types-of-databases/Relational/#denormalization","title":"Denormalization","text":"<p>Denormalization is a database optimization technique in which we add redundant data to one or more tables. This can help us avoid costly joins in a relational database.</p>"},{"location":"sprint02/","title":"Sprint goals","text":""},{"location":"sprint02/#dates","title":"Dates","text":"<p>From 06/03/2024 to 19/03/2024</p>"},{"location":"sprint02/#introduction","title":"Introduction","text":"<p>In this sprint, the groups of the CBL project have the following objectives:</p>"},{"location":"sprint02/#general","title":"General","text":"<ul> <li> Synchronize the local development environment with all team members</li> </ul>"},{"location":"sprint02/#class-p1","title":"Class P1","text":"<ul> <li> Understand what Node.js is and how it works</li> <li> Acquire knowledge about the basic capabilities of Node.js</li> <li> Finalize the logical / physical model of the project's database (if not already finalized)</li> <li> Define a preliminary plan for the provisioning of the defined database</li> </ul>"},{"location":"sprint02/#class-p2","title":"Class P2","text":"<ul> <li> Deepen the theoretical and practical knowledge of ReactJS (namely, with Routing, Redux, and, eventually, requests to APIs)</li> <li> Study the technological architecture of the projects developed in the first semester in the context of CBL</li> <li> Integration of the knowledge acquired so far in the projects</li> </ul>"},{"location":"sprint02/exercises/calculator/","title":"Calculator","text":""},{"location":"sprint02/exercises/calculator/#introduction","title":"Introduction","text":"<p>In this exercise, you will create a simple calculator using Node.js.</p>"},{"location":"sprint02/exercises/calculator/#instructions","title":"Instructions","text":"<ol> <li> <p>Create a new file named <code>calculator.js</code> and write a script that reads two numbers from the command line and prints the sum, difference, product, and quotient of the two numbers.</p> </li> <li> <p>Use the <code>process.argv</code> array to read the command line arguments.</p> </li> <li> <p>If the user does not provide two numbers, the script should print an error message and exit.</p> </li> <li> <p>If the user provides invalid numbers, the script should print an error message and exit.</p> </li> <li> <p>If the user provides a division by zero, the script should print an error message and exit.</p> </li> <li> <p>Test your script with different inputs.</p> </li> </ol>"},{"location":"sprint02/exercises/calculator/#documentation","title":"Documentation","text":"<ul> <li>Output in the command line: https://nodejs.org/en/learn/command-line/output-to-the-command-line-using-nodejs</li> <li>Reading command line arguments: https://www.geeksforgeeks.org/node-js-process-argv-property/</li> </ul>"},{"location":"sprint02/exercises/database/","title":"Connect to a database","text":""},{"location":"sprint02/exercises/database/#description","title":"Description","text":"<p>In this exercise, you will connect to a database using Nodejs.</p>"},{"location":"sprint02/exercises/database/#instructions","title":"Instructions","text":"<ol> <li> <p>Create a new file named <code>database.js</code> and write a script that connects to a database using the <code>mysql</code> package or similar.</p> </li> <li> <p>Use the <code>dotenv</code> package to load the database credentials from a <code>.env</code> file.</p> </li> <li> <p>If the connection is successful, print a success message in the console.</p> </li> <li> <p>If the connection fails, print an error message in the console.</p> </li> <li> <p>Create a users table with the following fields: id, name, email, and password.</p> </li> <li> <p>Insert a new user into the users table.</p> </li> <li> <p>Retrieve all users from the users table and print them in the console.</p> </li> </ol>"},{"location":"sprint02/exercises/database/#documentation","title":"Documentation","text":"<ul> <li>MySQL package: https://www.npmjs.com/package/mysql</li> </ul>"},{"location":"sprint02/exercises/environment-variables/","title":"Environment Variables","text":"<p>Objective: Write a Node.js script that reads an environment variable named USER_NAME and prints a greeting to the console. If the environment variable is not set, the script should print a default greeting.</p>"},{"location":"sprint02/exercises/environment-variables/#instructions","title":"Instructions","text":"<ol> <li>Create a new file named <code>greeting.js</code> and write a script that reads the <code>USER_NAME</code> environment variable and prints a greeting to the console. If the environment variable is not set, the script should throw an error.</li> </ol>"},{"location":"sprint02/exercises/environment-variables/#documentation","title":"Documentation","text":"<p>https://nodejs.org/en/learn/command-line/how-to-read-environment-variables-from-nodejs</p>"},{"location":"sprint02/exercises/full-day-report/","title":"Full day meteorology report","text":""},{"location":"sprint02/exercises/full-day-report/#introduction","title":"Introduction","text":"<p>In this exercise, you will create a simple Node.js application that fetches meteorological data from an API and stores it in a file.</p>"},{"location":"sprint02/exercises/full-day-report/#instructions","title":"Instructions","text":"<ol> <li>Create a new folder named <code>weather</code> and write a script that fetches meteorological data from the OpenWeatherMap API and store it a new file with the date as the name.</li> </ol>"},{"location":"sprint02/exercises/full-day-report/#advanced","title":"Advanced","text":"<ol> <li>Extend the solution in order to publish to a discord channel.</li> </ol>"},{"location":"sprint02/exercises/hello-world-server/","title":"Hello world server","text":""},{"location":"sprint02/exercises/hello-world-server/#introduction","title":"Introduction","text":"<p>In this exercise, you will create a simple Node.js server that responds with \"Hello World\" to any request.</p>"},{"location":"sprint02/exercises/hello-world-server/#instructions","title":"Instructions","text":"<ol> <li> <p>Create a new file named <code>server.js</code> and write a script that creates a server using the <code>http</code> module.</p> </li> <li> <p>The server should listen for requests on port <code>3000</code>.</p> </li> <li> <p>When a request is received, the server should respond with a <code>200</code> status code and a <code>text/plain</code> content type.</p> </li> <li> <p>The response body should contain the text \"Hello World\".</p> </li> <li> <p>Test your server by making a request to <code>http://localhost:3000</code> using your browser or a tool like <code>curl</code>.</p> </li> <li> <p>Accept a call /info that returns a json object to the client with the following structure: <pre><code>{\n  \"name\": \"John Doe\",\n  \"age\": 30,\n  \"city\": \"New York\"\n}\n</code></pre></p> </li> </ol>"},{"location":"sprint02/exercises/manipulating-files/","title":"Manipulating files using Nodejs and the <code>fs</code> module","text":"<p>In this exercise, you will create a simple Node.js script that reads a file and writes to a file using the <code>fs</code> module.</p>"},{"location":"sprint02/exercises/manipulating-files/#instructions","title":"Instructions","text":"<ol> <li>Create a new file named <code>persons.json</code> and write a JSON array with the following structure:</li> </ol> <pre><code>[\n  {\n    \"name\": \"John Doe\",\n    \"age\": 30,\n    \"city\": \"New York\"\n  },\n  {\n    \"name\": \"Jane Doe\",\n    \"age\": 25,\n    \"city\": \"Los Angeles\"\n  }\n]\n</code></pre> <ol> <li> <p>Create a new file named <code>file.js</code> and write a script that reads the <code>persons.json</code> file and prints the content to the console.</p> </li> <li> <p>Sort the array by the <code>name</code> property and print the sorted array to the console.</p> </li> <li> <p>Create a new file folder named results and write the sorted array to a file named <code>sorted-persons.json</code>.</p> </li> <li> <p>If the folder already exists don't throw an error, just write the file.</p> </li> <li> <p>Test your scripts by running them using the <code>node</code> command.</p> </li> </ol>"},{"location":"sprint02/exercises/manipulating-files/#documentation","title":"Documentation","text":"<ul> <li>Reading files using the <code>fs</code> module: https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback</li> <li>Writing files using the <code>fs</code> module: https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback</li> </ul>"},{"location":"sprint02/exercises/manipulating-files/#advanced","title":"Advanced","text":"<p>Find a way of doing this with promises and async/await.</p>"},{"location":"sprint02/exercises/scrapper/","title":"Scrapper","text":"<p>Save the information about Digimedia members available at: https://digimedia.web.ua.pt/people/ in a json file.</p>"},{"location":"sprint02/exercises/scrapper/#instructions","title":"Instructions","text":"<ol> <li>Create a new file named <code>scrapper.js</code> and write a script that fetches the information from the Digimedia website and saves it in a json file.</li> </ol>"},{"location":"sprint02/nodejs/introduction/","title":"Introduction to Node.js","text":"<p>NodeJS is a javascript runtime. Javascript is a programming language that until now you have only seen running in the browser in order to manipulate the DOM. However, NodeJS allows you to run javascript code also on the server (computers running somewhere on the internet) like a normal programming language.</p>"},{"location":"sprint02/nodejs/introduction/#how-does-this-work","title":"How does this work?","text":"<p>NodeJS is built on top of the V8 engine, which is the same engine that powers Google Chrome. The engine takes the javascript code and compiles it to machine code, which is the code that the computer can understand and execute. (Machine code) V8 itself is written in C++ and is open source.</p> <p>Basically Nodejs takes the v8 engine and adds some features to it, like the ability to interact with the file system, to create servers, to interact with databases, etc.</p> <p>In short it allows you to write server-side code in javascript.</p> <p>DOM features are not available in NodeJS, because it is not running in a browser environment and so there is no DOM to manipulate.</p>"},{"location":"sprint02/nodejs/introduction/#installation","title":"Installation","text":"<p>https://nodejs.org/en/download</p> <p>Or better (nvm):</p> <p>https://github.com/nvm-sh/nvm?tab=readme-ov-file#installing-and-updating</p> <p>NVM will allow you to install multiple versions of NodeJS and switch between them easily - might be useful if you are working on different projects that require different versions of NodeJS.</p>"},{"location":"sprint02/nodejs/introduction/#ways-of-running-nodejs-code","title":"Ways of running NodeJS code","text":"<ul> <li>REPL (Read-Eval-Print-Loop) - a simple interactive shell that allows you to run javascript code line by line. You can start it by typing <code>node</code> in the terminal.</li> </ul> <p>R: Read - reads user's input E: Eval - evaluates the user's input P: Print - prints the result L: Loop - loops back to the first step</p> <ul> <li>Running a file - you can write your code in a file and run it with the <code>node</code> command followed by the file name. For example <code>node myFile.js</code></li> </ul>"},{"location":"sprint02/nodejs/introduction/#hello-world","title":"Hello World","text":"<p>Let's start with a simple example. Create a file called <code>hello.js</code> and write the following code:</p> <pre><code>console.log('Hello World');\n</code></pre> <p>Now run the file with the <code>node</code> command:</p> <pre><code>node hello.js\n</code></pre>"},{"location":"sprint02/nodejs/introduction/#running-a-server-with-nodejs","title":"Running a server with nodejs","text":"<pre><code>const http = require('http');\n\nconst server = http.createServer((req, res) =&gt; {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World\\n');\n\n    // we can return anything we want here, for example an html file\n    // res.writeHead(200, {'Content-Type': 'text/html'});\n    // res.end('&lt;h1&gt;Hello World&lt;/h1&gt;');\n\n    // or a json\n    // res.writeHead(200, {'Content-Type': 'application/json'});\n    // res.end('{\"message\": \"Hello World\"}');\n\n});\n\nserver.listen(3000, 'Server running at http://localhost:3000/');\n</code></pre> <p>In PHP for example, in order to run a server you would need to install a server like Apache or Nginx. With NodeJS you can create a server with just a few lines of code.</p>"},{"location":"sprint02/nodejs/introduction/#nodejs-usecases","title":"NodeJS usecases","text":"<ul> <li> <p>APIs - you can create a server that listens for requests and sends back responses. This is useful for creating APIs that can be used by other applications.</p> </li> <li> <p>Backend for web applications - you can create a server that serves web pages and handles requests from the client.</p> </li> <li> <p>Automation - you can write scripts that automate tasks on your computer, like moving files, downloading files, etc.</p> </li> <li> <p>Microservices - you can create small services that do one thing and do it well, and then combine them to create a bigger application.</p> </li> <li> <p>Real-time applications - you can create applications that require real-time communication between the server and the client, like chat applications, games, etc.</p> </li> <li> <p>Command line tools - you can create command line tools that can be used to perform tasks from the terminal.</p> </li> <li> <p>IoT - you can write code that runs on small devices like Raspberry Pi, Arduino, etc.</p> </li> <li> <p>Desktop applications - you can create desktop applications using frameworks like Electron.</p> </li> </ul>"},{"location":"sprint02/nodejs/introduction/#alternatives","title":"Alternatives","text":"<ul> <li>PHP</li> <li>Python</li> <li>Ruby</li> <li>Java</li> </ul>"},{"location":"sprint02/nodejs/introduction/#npm-package-manager","title":"NPM package manager","text":"<p>npm is the standard package manager for Node.js.</p> <p>In September 2022 over 2.1 million packages were reported being listed in the npm registry, making it the biggest single language code repository on Earth, and you can be sure there is a package for (almost!) everything.</p> <p>To start using npm on a project you can run <code>npm init</code> in the terminal. This will create a <code>package.json</code> file that will hold all the information about your project and its dependencies.</p> <p>To install a package you can run <code>npm install packageName</code>. This will install the package and add it to the <code>package.json</code> file.</p> <p>To install a package globally you can run <code>npm install -g packageName</code>. This will install the package globally on your computer and you will be able to use it from the terminal.</p>"},{"location":"sprint02/nodejs/javascript-refresher/","title":"Javascript refresher for NodeJS","text":"<p>Here you can find the concepts that we should refresh before starting with NodeJS. Understanding and praticing these concepts is essential to understand the next classes and topics.</p>"},{"location":"sprint02/nodejs/javascript-refresher/#javascript-short-summary","title":"Javascript short summary","text":"<ul> <li>Weakly typed language - you don't have to declare the type of a variable when you declare it. The type will be inferred from the value that you assign to it. Example:</li> </ul> <pre><code>let a = 5; // a is a number\nlet b = 'hello'; // b is a string\n</code></pre> <ul> <li>Object-oriented - everything is an object, even functions. You can create objects using the <code>new</code> keyword. Example of creating a new function:</li> </ul> <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nlet person1 = new Person('John', 25);\n\n// example of extending the prototype of a function\nPerson.prototype.sayHello = function() {\n  console.log('Hello, my name is ' + this.name);\n}\n\nperson1.sayHello(); // Hello, my name is John\n</code></pre> <ul> <li>Versatile - you can use javascript to create web applications, mobile applications, desktop applications, games, etc.</li> </ul>"},{"location":"sprint02/nodejs/javascript-refresher/#variables","title":"Variables","text":"<p>Variables are used to store data. You can declare a variable using the <code>let</code> keyword.</p> <pre><code>let a = 5;\nlet b = 'hello';\nlet c = true;\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#ways-to-declare-a-variable","title":"Ways to declare a variable","text":"<ul> <li><code>let</code> - you can change the value of the variable</li> <li><code>const</code> - you can't change the value of the variable - If something doesn't need to change, it's better to use <code>const</code> instead of <code>let</code>!</li> <li><code>var</code> - you can change the value of the variable, but it has some issues, so it's better to use <code>let</code> instead</li> </ul> <p>Issues of using var instead of let: var is function scoped, while let is block scoped. This means that if you declare a variable with var inside a block, it will be available outside the block. This javascript behavior is called hoisting.</p> <pre><code>if (true) {\n  var a = 5;\n}\n\nconsole.log(a); // 5\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#functions","title":"Functions","text":"<p>Functions are used to group code that you want to reuse. You can declare a function using the <code>function</code> keyword.</p> <pre><code>function sayHello() {\n  console.log('Hello');\n}\n</code></pre> <p>You can also declare a function using an arrow function:</p> <pre><code>let sayHello = () =&gt; {\n  console.log('Hello');\n}\n</code></pre> <p><code>this</code> keyword difference between arrow functions and regular functions:</p> <pre><code>function Person(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayHello = function() {\n    console.log('Hello, my name is ' + this.name);\n  }\n}\n\nlet person1 = new Person('John', 25);\nperson1.sayHello(); // Hello, my name is John\n\nlet sayHello = () =&gt; {\n  console.log('Hello, my name is ' + this.name);\n}\n\nlet person2 = {\n  name: 'John',\n  age: 25,\n  sayHello: sayHello\n}\n\nperson2.sayHello(); // Hello, my name is undefined\n</code></pre> <p>This happens because arrow functions don't have their own <code>this</code> keyword. They inherit the <code>this</code> keyword from the parent scope.</p>"},{"location":"sprint02/nodejs/javascript-refresher/#objects","title":"Objects","text":"<p>Objects are used to store multiple values. You can create an object using the <code>{}</code> syntax.</p> <pre><code>const person = {\n  name: 'John',\n  'last-name': 'Doe',\n  age: 25,\n  sayHello: function() {\n    console.log('Hello, my name is ' + this.name);\n  }\n}\n</code></pre> <p>You can access the properties of an object using the <code>.</code> syntax:</p> <pre><code>console.log(person.name); // John\n</code></pre> <p>You can also access the properties of an object using the <code>[]</code> syntax:</p> <pre><code>console.log(person['last-name']); // Doe\n</code></pre> <p>You can add new properties to an object using the <code>.</code> syntax:</p> <pre><code>person.city = 'Lisbon';\n</code></pre> <p>Even though person is declared as a <code>const</code>, you can change the properties of the object. You can't change the object itself, but you can change its properties. This happens because the object is stored in memory and the <code>const</code> keyword only prevents the variable from being reassigned.</p>"},{"location":"sprint02/nodejs/javascript-refresher/#object-methods","title":"Object methods","text":"<ul> <li><code>Object.keys(person)</code> - returns an array with the keys of the object</li> <li><code>Object.values(person)</code> - returns an array with the values of the object</li> <li><code>Object.entries(person)</code> - returns an array with the entries of the object</li> </ul> <p>Full list at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object</p>"},{"location":"sprint02/nodejs/javascript-refresher/#arrays","title":"Arrays","text":"<p>Arrays are used to store multiple values. You can create an array using the <code>[]</code> syntax.</p> <pre><code>const numbers = [1, 2, 3, 4, 5];\n</code></pre> <p>You can access the elements of an array using the <code>[]</code> syntax:</p> <pre><code>console.log(numbers[0]); // 1\n</code></pre> <p>You can add new elements to an array using the <code>push</code> method:</p> <pre><code>numbers.push(6);\n</code></pre> <p>You can remove elements from an array using the <code>pop</code> method:</p> <pre><code>numbers.pop();\n</code></pre> <p>Full list of array methods at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array</p>"},{"location":"sprint02/nodejs/javascript-refresher/#loops","title":"Loops","text":"<p>Loops are used to execute a block of code multiple times. You can create a loop using the <code>for</code> keyword.</p> <pre><code>for (let i = 0; i &lt; 5; i++) {\n  console.log(i);\n}\n</code></pre> <p>You can also create a loop using the <code>while</code> keyword:</p> <pre><code>let i = 0;\n\nwhile (i &lt; 5) {\n  console.log(i);\n  i++;\n}\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#conditionals","title":"Conditionals","text":"<p>Conditionals are used to execute a block of code if a condition is true. You can create a conditional using the <code>if</code> keyword.</p> <pre><code>let age = 25;\n\n\nif (age &gt;= 18) {\n  console.log('You are an adult');\n} else {\n  console.log('You are a child');\n}\n</code></pre> <p>You can also create a conditional using the <code>switch</code> keyword:</p> <pre><code>let day = 'Monday';\n\nswitch (day) {\n  case 'Monday':\n    console.log('It is Monday');\n    break;\n  case 'Tuesday':\n    console.log('It is Tuesday');\n    break;\n  default:\n    console.log('It is another day');\n}\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#classes","title":"Classes","text":"<p>Classes are used to create objects. You can create a class using the <code>class</code> keyword.</p> <pre><code>class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  sayHello() {\n    console.log('Hello, my name is ' + this.name);\n  }\n}\n\nlet person1 = new Person('John', 25);\nperson1.sayHello();\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#spread-and-rest-operators","title":"Spread and rest operators","text":"<p>The spread operator is used to expand an array or an object. You can use the spread operator to create a new array or object with the elements of the original array or object.</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\nlet newNumbers = [...numbers, 6, 7, 8, 9, 10];\n</code></pre> <p>The rest operator is used to collect the remaining elements of an array or an object. You can use the rest operator to create a new array or object with the remaining elements of the original array or object.</p> <pre><code>let [first, second, ...rest] = [1, 2, 3, 4, 5];\nconsole.log(rest); // [3, 4, 5]\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#destructuring","title":"Destructuring","text":"<p>Destructuring is used to extract values from an array or an object. You can use destructuring to create variables from the elements of an array or the properties of an object.</p> <pre><code>let numbers = [1, 2, 3, 4, 5];\nlet [first, second, ...rest] = numbers;\nconsole.log(first); // 1\nconsole.log(second); // 2\nconsole.log(rest); // [3, 4, 5]\n</code></pre> <pre><code>let person = {\n  name: 'John',\n  age: 25,\n  city: 'Lisbon'\n}\n\nlet {name, age, city} = person;\n\nconsole.log(name); // John\nconsole.log(age); // 25\nconsole.log(city); // Lisbon\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#callbacks","title":"Callbacks","text":"<p>Callbacks are used to handle asynchronous operations. You can create a callback function and pass it as an argument to another function.</p> <pre><code>function doSomething(callback) {\n  setTimeout(() =&gt; {\n    callback('Success');\n  }, 1000);\n}\n\ndoSomething((value) =&gt; {\n  console.log(value); // Success\n});\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#promises","title":"Promises","text":"<p>Promises are used to handle asynchronous operations. You can create a promise using the <code>Promise</code> constructor.</p> <pre><code>let promise = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    resolve('Success');\n  }, 1000);\n});\n\npromise.then((value) =&gt; {\n  console.log(value); // Success\n});\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#asyncawait","title":"Async/await","text":"<p>Async/await is used to handle asynchronous operations. You can create an async function using the <code>async</code> keyword and use the <code>await</code> keyword to wait for the result of a promise.</p> <pre><code>let promise = new Promise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    resolve('Success');\n  }, 1000);\n});\n\nlet asyncFunction = async () =&gt; {\n  let value = await promise;\n  console.log(value); // Success\n}\n\nasyncFunction();\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#template-literals","title":"Template literals","text":"<p>Template literals are used to create strings. You can create a template literal using the `` syntax.</p> <pre><code>let name = 'John';\nlet age = 25;\n\nlet message = `Hello, my name is ${name} and I am ${age} years old`;\nconsole.log(message); // Hello, my name is John and I am 25 years old\n</code></pre>"},{"location":"sprint02/nodejs/javascript-refresher/#modules-in-nodejs","title":"Modules in NodeJS","text":"<p>In NodeJS, you can use the <code>require</code> function to import modules. You can create a module using the <code>module.exports</code> object.</p> <pre><code>// myModule.js\n\nmodule.exports = {\n  sayHello: function() {\n    console.log('Hello');\n  }\n}\n</code></pre> <pre><code>// index.js\n\nlet myModule = require('./myModule');\n\nmyModule.sayHello(); // Hello\n</code></pre>"},{"location":"sprint02/server-side/","title":"What happens when I access a website?","text":"<p>Whenever you visit a website, your browser sends a request to the server where the website is hosted. The server then processes the request and sends back the requested information to your browser. This process uses the HTTP (Hypertext Transfer Protocol) protocol, which is a set of rules that allows the transfer of files, such as text, images, and videos, on the web.</p> <p></p>"},{"location":"sprint02/server-side/#steps-when-accessing-a-website","title":"Steps when accessing a website","text":""},{"location":"sprint02/server-side/#dns-resolution","title":"DNS resolution:","text":"<p>Your browser needs to know the IP address of the server where the website is hosted. To do this, it sends a request to a DNS server, which returns the IP address of the server.</p>"},{"location":"sprint02/server-side/#http-request-your-browser-sends-an-http-request-to-the-server-asking-for-the-websites-content","title":"HTTP request: Your browser sends an HTTP request to the server, asking for the website's content.","text":"<p>Rules of communication between the client and the server are set by the HTTP protocol. The request is composed of a method (GET, POST, PUT, DELETE, etc.), a path (the URL), and a version of the protocol.</p> <p>Example of an HTTP request (index.html):</p> <pre><code>GET /index.html HTTP/1.1\nHost: www.example.com\n</code></pre>"},{"location":"sprint02/server-side/#processing-the-request-the-server-processes-the-request-and-sends-back-the-requested-information-to-your-browser","title":"Processing the request: The server processes the request and sends back the requested information to your browser.","text":"<p>Example of the response:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: text/html\n\n-- Response body --\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My website&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello World&lt;/h1&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"sprint02/server-side/#rendering-the-website-your-browser-receives-the-information-and-renders-the-website-for-you-to-see","title":"Rendering the website: Your browser receives the information and renders the website for you to see.","text":"<p>This is a simplified explanation of what happens when you access a website. There are many other steps involved, such as SSL/TLS negotiation, caching, and more.</p> <p></p>"},{"location":"sprint02/server-side/#accessing-an-website-with-nodejs-example","title":"Accessing an website with NodeJS example:","text":"<pre><code>const http = require('http');\n\nconst server = http.createServer((req, res) =&gt; {\n  res.writeHead(200, {'Content-Type': 'text/plain'});\n  res.end('Hello World\\n');\n});\n\nserver.listen(3000, 'Server running at http://localhost:3000/');\n</code></pre>"},{"location":"sprint03/","title":"Sprint goals","text":""},{"location":"sprint03/#dates","title":"Dates","text":"<p>From 20/03/2024 to 09/04/2024</p>"},{"location":"sprint03/#introduction","title":"Introduction","text":"<p>In this sprint, the groups of the CBL project have the following objectives:</p>"},{"location":"sprint03/#general","title":"General","text":"<ul> <li> Synchronize the local development environment with all team members</li> </ul>"},{"location":"sprint03/#class-p1","title":"Class P1","text":"<ul> <li> Define the preliminary structure for the project's REST API</li> <li> Create the repository and the project for the API development</li> <li> Create the preliminary routes of the API using Express.js or similar</li> <li> Database integration in the API defined routes</li> <li> Move the local mocks of the project to be served by the API</li> </ul>"},{"location":"sprint03/#class-p2","title":"Class P2","text":"<ul> <li> Continue the deepening of advanced theoretical and practical knowledge of ReactJS</li> <li> Continue studying the technological architecture of the projects</li> <li> Integration of the knowledge acquired in the projects</li> </ul>"},{"location":"sprint03/1-REST-API%27s/","title":"Introduction to REST API's","text":""},{"location":"sprint03/1-REST-API%27s/#what-is-an-api","title":"What is an API?","text":"<p>API stands for Application Programming Interface. It is a set of rules and protocols that allows different software applications to communicate with each other. It defines the methods and data formats that applications can use to request and exchange data. APIs are used to enable the integration of different systems and to allow them to work together.</p>"},{"location":"sprint03/1-REST-API%27s/#what-is-a-restful-api","title":"What is a REST(ful) API?","text":"<p>REST (Representational State Transfer) is an architectural style for designing applications. It relies on a stateless, client-server, cacheable communications protocol. REST applications use HTTP requests to perform four operations: GET (read), POST (create), PUT (update), and DELETE (delete). REST is a lightweight alternative to other web services, such as SOAP (Simple Object Access Protocol).</p> <p>A system that complies with all the REST constraints is called a RESTful system.</p>"},{"location":"sprint03/1-REST-API%27s/#constraints-in-a-restful-api","title":"Constraints in a RESTful API","text":"<p>The REST architectural style describes six constraints. These constraints are:</p> <p>REST defines 6 architectural constraints that make any web service \u2013 a truly RESTful API.</p> <ol> <li>Uniform interface</li> <li>Client-server</li> <li>Stateless</li> <li>Cacheable</li> <li>Layered system</li> <li>Code on demand (optional)</li> </ol>"},{"location":"sprint03/1-REST-API%27s/#1-uniform-interface","title":"1. Uniform interface","text":"<p>As the constraint name itself applies, you MUST decide APIs interface for resources inside the system which are exposed to API consumers and follow religiously. A resource in the system should have only one logical URI, and that should provide a way to fetch related or additional data. It\u2019s always better to synonymize a resource with a web page.</p> <p>Any single resource should not be too large and contain each and everything in its representation. Whenever relevant, a resource should contain links (HATEOAS) pointing to relative URIs to fetch related information.</p> <p>Also, the resource representations across the system should follow specific guidelines such as naming conventions, link formats, or data format (JSON).</p> <p>All resources should be accessible through a common approach such as HTTP GET and similarly modified using a consistent approach.</p>"},{"location":"sprint03/1-REST-API%27s/#2-client-server","title":"2. Client-server","text":"<p>This constraint essentially means that client applications and server applications MUST be able to evolve separately without any dependency on each other. A client should know only resource URIs, and that\u2019s all. Today, this is standard practice in web development, so nothing fancy is required from your side.</p>"},{"location":"sprint03/1-REST-API%27s/#3-stateless","title":"3. Stateless","text":"<p>The server should not store any client context session. The session state is kept entirely on the client. This constraint helps to scale the server and client interactions. It further helps to improve the visibility of interactions, reliability, and scalability.</p>"},{"location":"sprint03/1-REST-API%27s/#4-cacheable","title":"4. Cacheable","text":"<p>As on the World Wide Web, clients and intermediaries can cache responses. Responses must, therefore, implicitly or explicitly define themselves as cacheable or not to prevent clients from reusing stale or inappropriate data in response to further requests.</p> <p>In REST, caching shall be applied to resources when applicable, and then these resources MUST declare themselves cacheable. Caching can be implemented on the server or client side.</p>"},{"location":"sprint03/1-REST-API%27s/#5-layered-system","title":"5. Layered system","text":"<p>REST allows you to use a layered system architecture where you deploy the APIs on server A, and store data on server B and authenticate requests in Server C, for example. This helps to improve the scalability of the system. The layered system helps to enforce security policies, load balancing, shared caches, and other cross-cutting concerns.</p>"},{"location":"sprint03/1-REST-API%27s/#6-code-on-demand-optional","title":"6. Code on demand (optional)","text":"<p>REST allows client functionality to be extended by downloading and executing code in the form of applets or scripts. This simplifies clients by reducing the number of features required to be pre-implemented.</p>"},{"location":"sprint03/1-REST-API%27s/#key-concepts-in-restful-apis","title":"Key concepts in RESTful APIs","text":""},{"location":"sprint03/1-REST-API%27s/#api-endpoints-and-resources","title":"API endpoints and resources","text":"<p>An API endpoint is a point at which an API can access the resources they need from a server. It is a server route that is used to retrieve different data from the API. An endpoint is a URL pattern used to retrieve data from the API. The endpoint is the URL of the server. Each endpoint is the location from which APIs can access the resources they need to carry out their function.</p> <p>A resource is an object with a type, associated data, relationships to other resources, and a set of methods that operate on it. It is a fundamental concept used in the RESTful architecture. It can be any object, data, or service that can be accessed by the client.</p>"},{"location":"sprint03/1-REST-API%27s/#http-methods-get-post-put-delete-etc","title":"HTTP methods (GET, POST, PUT, DELETE, etc...)","text":"<p>HTTP defines a set of request methods to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred to as HTTP verbs. The most common used methods in a RESTful API are:</p> <ul> <li> <p>GET: Used for retrieving data from the server.</p> </li> <li> <p>POST: Used for sending data to the server to create a new resource.</p> </li> <li> <p>PUT: Used for sending data to the server to update a resource.</p> </li> <li> <p>DELETE: Used to delete a resource from the server.</p> </li> </ul> <p>And many others with more specific purposes:</p> <ul> <li> <p>PATCH: The PATCH method is used to apply partial modifications to a resource.</p> </li> <li> <p>HEAD: The HEAD method asks for a response identical to that of a GET request, but without the response body. It is useful for retrieving meta-information written in response headers, without having to transport the entire content.</p> </li> <li> <p>OPTIONS: The OPTIONS method is used to describe the communication options for the target resource.</p> </li> </ul>"},{"location":"sprint03/1-REST-API%27s/#query-parameters-and-url-structure","title":"Query parameters and URL structure","text":"<p>Query parameters are used to filter the data returned by the API. They are added to the end of the URL and are separated from the URL by a question mark. They are used to specify the data that should be returned by the API. For example, if you want to retrieve all the users with the name \"John\", you can use a query parameter to filter the data.</p>"},{"location":"sprint03/1-REST-API%27s/#responses-status-codes-error-handling","title":"Responses &amp; status codes &amp; error handling","text":"<p>When a RESTful API is called, the server will return a response. The response is composed of a status code and a response body. The status code indicates the success or failure of the request. The response body contains the data requested by the client.</p>"},{"location":"sprint03/1-REST-API%27s/#status-codes","title":"Status codes","text":"<p>Commonly used groups of status codes in RESTful APIs are:</p> <ul> <li>2xx Success: The action was successfully received, understood, and accepted.</li> <li>3xx Redirection: Further action must be taken in order to complete the request.</li> <li>4xx Client Error: The request contains bad syntax or cannot be fulfilled.</li> <li>5xx Server Error: The server failed to fulfill an apparently valid request.</li> </ul> <p>Some of the most common status codes are:</p> <ul> <li>200 OK: The request was successful.</li> <li>201 Created: The request was successful and a new resource was created.</li> <li>301 Moved Permanently: The requested resource has been permanently moved to a new location.</li> <li>302 Found: The requested resource has been temporarily moved to a different location.</li> <li>304 Not Modified: The client can use cached data as the response has not been modified.</li> <li>307 Temporary Redirect: The requested resource has been temporarily moved to a different location.</li> <li>308 Permanent Redirect: The requested resource has been permanently moved to a different location.</li> <li>400 Bad Request: The request was invalid.</li> <li>401 Unauthorized: The request did not include the necessary authentication credentials.</li> <li>403 Forbidden: The server understood the request, but is refusing to fulfill it.</li> <li>404 Not Found: The requested resource could not be found.</li> <li>500 Internal Server Error: The server encountered an unexpected condition that prevented it from fulfilling the request.</li> </ul>"},{"location":"sprint03/1-REST-API%27s/#authentication-and-authorization","title":"Authentication and authorization","text":"<p>Authentication is the process of verifying the identity of a user. Authorization is the process of verifying what the user has access to. In RESTful APIs, authentication and authorization are handled using tokens. A token is a piece of data that is used to authenticate a user. It is usually a long string of characters that is sent along with each request to the server. The server then verifies the token and sends back the requested data if the token is valid.</p>"},{"location":"sprint03/1-REST-API%27s/#best-practices-for-designing-restful-apis","title":"Best practices for designing RESTful APIs","text":"<p>When designing RESTful APIs, there are some best practices that should be followed:</p> <ul> <li> <p>Use nouns instead of verbs in endpoint URLs: The URL should contain the name of the resource that the API interacts with. It should not contain the action that the API performs.</p> </li> <li> <p>Use plural nouns: The URL should contain the plural form of the resource name.</p> </li> <li> <p>Use sub-resources for relations: If a resource is related to another resource, the URL should contain the parent resource and the child resource.</p> </li> <li> <p>Use HTTP methods: Use HTTP methods to operate on the resource. For example, use GET to retrieve a resource, POST to create a new resource, PUT to update a resource, and DELETE to delete a resource.</p> </li> <li> <p>Be consistent: Use the same URL structure for all resources. This makes the API easier to understand and use.</p> </li> <li> <p>Handle errors gracefully: When an error occurs, return an appropriate HTTP status code and an error message.</p> </li> <li> <p>Use pagination for large data sets: If an API returns a large data set, use pagination to limit the amount of data returned.</p> </li> <li> <p>Version your API: If you make breaking changes to your API, version it so that existing clients are not affected.</p> </li> <li> <p>Document your API: Provide clear and complete documentation for your API so that developers can easily understand and use it.</p> </li> <li> <p>Use consistent naming conventions: Use consistent naming conventions for your API. For example, use camel case for JSON keys.</p> </li> <li> <p>Use plural nouns: Use plural nouns for resource names.</p> </li> <li> <p>Use query parameters for filtering: Use query parameters to filter the data returned by the API.</p> </li> <li> <p>Use HATEOAS: Use HATEOAS (Hypermedia as the Engine of Application State) to provide links to related resources in the response.</p> </li> <li> <p>Use JSON as the default format: Use JSON as the default format for request and response data.</p> </li> <li> <p>Use HTTP status codes: Use appropriate HTTP status codes to indicate the success or failure of a request.</p> </li> <li> <p>Use HTTP headers: Use HTTP headers to provide additional information about the request or response.</p> </li> <li> <p>Use HTTP caching: Use HTTP caching to improve the performance of the API.</p> </li> <li> <p>Use rate limiting: Use rate limiting to prevent abuse of the API.</p> </li> </ul>"},{"location":"sprint03/1-REST-API%27s/exercises/first-REST-API/","title":"First REST API (with Express.js)","text":""},{"location":"sprint03/1-REST-API%27s/exercises/first-REST-API/#introduction","title":"Introduction","text":"<p>In this exercise, you will create your first REST API using Express.js. You will create a simple API that will allow you to perform CRUD operations on a collection of items.</p>"},{"location":"sprint03/1-REST-API%27s/exercises/first-REST-API/#instructions","title":"Instructions","text":"<ol> <li>Individually create a repository for the challenge</li> <li>Define a database with 1 table (users / products)</li> <li>Plan the necessary routes to list, create, update and delete users</li> <li>Implement a basic API using Express.js</li> </ol>"},{"location":"sprint03/1-REST-API%27s/exercises/first-REST-API/#resources","title":"Resources","text":"<ul> <li>Express.js</li> <li>Postman</li> </ul>"},{"location":"sprint03/2-MVC/","title":"Model View Controller (MVC)","text":"<p>Structuring your code is important. It helps you to keep your code organized and maintainable. </p> <p>One of the most popular ways to structure your code is the Model View Controller (MVC) pattern.</p>"},{"location":"sprint03/2-MVC/#what-is-mvc","title":"What is MVC?","text":"<p>MVC is mostly about separation of concerns. It divides your code into three main components:</p> <ul> <li> <p>Model (Database representation): This is where your data is stored. It represents the data that you are working with. It is responsible for managing the data and the business logic of your application.</p> <ul> <li>Each model is a representation of a table in the database.</li> <li>Each model has a set of methods that allow you to interact with the data in the database. (save, fetch, delete, etc.)</li> </ul> </li> <li> <p>View (Route handler): This is what the user sees. It is responsible for displaying the data to the user. It is the user interface of your application.</p> <ul> <li>What the user sees.</li> <li>Decoupled from the model.</li> </ul> </li> <li> <p>Controller (Routes logic): This is the middleman between the Model and the View. It is responsible for handling the user input and updating the Model and the View accordingly.</p> <ul> <li>Connection poing between the model and the view.</li> </ul> </li> </ul>"},{"location":"sprint03/2-MVC/#why-use-mvc","title":"Why use MVC?","text":"<ul> <li> <p>Separation of concerns: It helps you to keep your code organized and maintainable. Each component has a specific role and is responsible for a specific part of the application.</p> </li> <li> <p>Reusability: You can reuse the same model or view in different parts of your application.</p> </li> <li> <p>Scalability: It makes it easier to scale your application. You can add new features or modify existing ones without affecting the other parts of the application.</p> </li> <li> <p>Testability: It makes it easier to test your application. You can test each component separately, which makes it easier to find and fix bugs.</p> </li> </ul>"},{"location":"sprint03/2-MVC/#example","title":"Example","text":"<p>Let's take a simple example to understand how MVC works</p> <p>Suppose you have a simple application that allows users to create, read, update, and delete posts.</p> <ul> <li> <p>Model: The model will represent the data of the posts. It will have methods to save, fetch, update, and delete posts.</p> </li> <li> <p>View: The view will display the posts to the user. It will have a form to create a new post and a list of posts.</p> </li> <li> <p>Controller: The controller will handle the user input. It will have routes to create, read, update, and delete posts. It will update the model and the view accordingly.</p> </li> </ul> <p></p> <p>Here is how the MVC components will interact with each other:</p> <ol> <li> <p>The user creates a new post by filling out a form in the view.</p> </li> <li> <p>The controller receives the user input and creates a new post in the model.</p> </li> <li> <p>The model saves the new post in the database.</p> </li> <li> <p>The controller fetches all the posts from the model.</p> </li> <li> <p>The view displays the list of posts to the user.</p> </li> </ol> <p>This is a simple example of how MVC works. It helps you to keep your code organized and maintainable. It separates the data, the user interface, and the business logic of your application. It makes it easier to scale and test your application. It is a popular pattern used in web development to structure your code.</p>"},{"location":"sprint03/2-MVC/#example-in-nodejs-express","title":"Example in Node.js + express","text":"<p>Here is an example of how you can implement MVC in Node.js using express:</p>"},{"location":"sprint03/2-MVC/#model","title":"Model","text":"<pre><code>// models/post.js\nconst posts = [\n    {\n        id: 1,\n        title: 'Post 1',\n        content: 'Content of post 1'\n    },\n    {\n        id: 2,\n        title: 'Post 2',\n        content: 'Content of post 2'\n    }\n];\n\nfunction fetchAll() {\n    return posts;\n}\n\nfunction save(post) {\n    posts.push(post);\n}\n\nmodule.exports = {\n    fetchAll,\n    save\n};\n</code></pre>"},{"location":"sprint03/2-MVC/#view","title":"View","text":"<pre><code>// routes/posts.js\n\nconst PostController = require('../controllers/posts');\n\nconst router = express.Router();\n\nrouter.get('/posts', PostController.getPosts);\n\nrouter.post('/posts', PostController.createPost);\n\nmodule.exports = router;\n</code></pre>"},{"location":"sprint03/2-MVC/#controller","title":"Controller","text":"<p><pre><code>// controllers/posts.js\n\nconst express = require('express');\n\nconst Post = require('../models/post');\n\nfunction getPosts(req, res) {\n    const posts = Post.fetchAll();\n    res.send(posts);\n}\n\nfunction createPost(req, res) {\n    const post = new Post(req.body);\n    post.save();\n    res.send('Post created');\n}\n\n\nmodule.exports = {\n    getPosts,\n    createPost\n};\n</code></pre> In this example, we have separated the data, the user interface, and the business logic of the application. The model represents the data of the posts. The view displays the posts to the user. The controller handles the user input and updates the model and the view accordingly.</p>"},{"location":"sprint03/3-ORM%27s/","title":"Definition &amp; Advantages/Disadvantages of ORM's","text":"<p>Object mappers are a common way to interact with databases in a more object-oriented way. They allow you to interact with the database using objects and methods, rather than writing raw SQL queries. This can make your code more readable and maintainable, as well as reducing the amount of boilerplate code you need to write.</p> <p>Depending on the database you are using, you may need to use a different type of object mapper. For example, if you are using a relational database like MySQL or PostgreSQL, you will need to use an Object-Relational Mapper (ORM). If you are using a document database like MongoDB, you will need to use an Object-Document Mapper (ODM). If you are using a graph database like Neo4j, you will need to use an Object-Graph Mapper (OGM).</p> <p></p>"},{"location":"sprint03/3-ORM%27s/#advantages-of-using-an-object-mapper","title":"Advantages of using an object mapper","text":"<p>There are several advantages to using an object mapper:</p> <ul> <li>Simpler code: Object mappers abstract away the complexity of interacting with the database, making your code simpler and easier to read.</li> <li>Reduced boilerplate: Object mappers handle common tasks like creating, updating, and deleting records, reducing the amount of boilerplate code you need to write.</li> <li>Type safety: Object mappers can provide type safety, ensuring that your code is less error-prone.</li> <li>Database independence: Object mappers can make your code more portable, as they can often work with multiple database systems.</li> </ul>"},{"location":"sprint03/3-ORM%27s/#disadvantages-of-using-an-object-mapper","title":"Disadvantages of using an object mapper","text":"<p>While object mappers can be useful, they also have some disadvantages:</p> <ul> <li>Performance: Object mappers can introduce overhead, which can impact the performance of your application.</li> <li>Learning curve: Object mappers can have a steep learning curve, especially if you are new to the technology.</li> <li>Complexity: Object mappers can add complexity to your codebase, especially for simple applications.</li> </ul>"},{"location":"sprint03/3-ORM%27s/ODM%20%28document%20DB%29/","title":"Definition &amp; Examples of ODM's","text":"<p>An Object-Document Mapper (ODM) is a tool that allows you to interact with your MongoDB database using JavaScript objects. It maps your objects in the application to documents in the database.</p> <p>Usually, when you interact with a MongoDB database, you work directly with the documents in the database, which are stored in a format called BSON (a binary version of JSON). You use MongoDB commands when you want to create, read, update, or delete a document.</p> <p>An ODM, like Mongoose, provides a way to interact with the documents in the database using JavaScript objects. With Mongoose, you can define a schema (a blueprint) for your objects and then use it to create instances of those objects. These instances can be saved, retrieved, updated and deleted in the database using mongoose methods.</p> <p>Short: Is a tool that allows you to interact with your MongoDB database using JavaScript objects</p> <p>Some popular ODM's for Node.js with MongoDB are:</p> <p>Mongoose Mongoskin Monk (...)</p> <p>Here is an example of how you can use Mongoose to interact with a MongoDB database:</p> <pre><code>const mongoose = require('mongoose');\n\nconst UserSchema = new mongoose.Schema({\n    // Schema definitions here\n    firstName: {\n        type: String,\n        required: true\n    },\n    lastName: String\n});\n\nconst User = mongoose.model('User', UserSchema);\n\n// Connecting to MongoDB\nmongoose.connect('mongodb://localhost/my_database', {\n    useNewUrlParser: true,\n    useUnifiedTopology: true\n});\n\n// fetching all users\nconst users = await User.find();\n\n// creating a new user\nconst user = new User({\n    firstName: 'John',\n    lastName: 'Doe'\n});\nawait user.save();\n\n// updating a user\nawait User.findOneAndUpdate({ lastName: 'Doe' }, { firstName: 'Jane' });\n\n// deleting a user\nawait User.findOneAndDelete({ lastName: 'Doe' });\n</code></pre>"},{"location":"sprint03/3-ORM%27s/ODM%20%28document%20DB%29/#core-concepts-in-mongoose","title":"Core concepts in Mongoose","text":"<ul> <li>Schemas: In Mongoose, schemas are used to define the structure of documents within a collection. They specify the types of fields, validation requirements, default values, and more. Example:</li> </ul> <pre><code>const UserSchema = new mongoose.Schema({\n    // Schema definitions here\n    firstName: {\n        type: String,\n        required: true\n    },\n    lastName: String\n});\n</code></pre> <ul> <li>Nested Schemas: Mongoose allows you to define nested schemas, which can be used to represent complex data structures.</li> </ul> <pre><code>const AddressSchema = new mongoose.Schema({\n    street: String,\n    city: String,\n    zip: String\n});\n\nconst UserSchema = new mongoose.Schema({\n    firstName: String,\n    lastName: String,\n    address: AddressSchema\n});\n</code></pre> <ul> <li>Populate: Mongoose provides a <code>populate</code> method to fetch related documents from other collections. This is useful when you have relationships between documents.</li> </ul> <pre><code>const UserSchema = new mongoose.Schema({\n    firstName: String,\n    lastName: String,\n    posts: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Post' }]\n});\n\nconst PostSchema = new mongoose.Schema({\n    title: String,\n    content: String\n});\n\nconst User = mongoose.model('User', UserSchema);\nconst Post = mongoose.model('Post', PostSchema);\n\nconst user = await User.findOne().populate('posts');\n</code></pre> <ul> <li>Models: Models are constructors compiled from schemas. They represent documents in a collection and provide an interface for querying and manipulating data.</li> </ul> <pre><code>const User = mongoose.model('User', UserSchema);\n</code></pre> <ul> <li>Queries: Mongoose provides a rich set of query methods to interact with the database. You can use these methods to find, update, delete, and perform other operations on documents.</li> </ul> <pre><code>// finding a user\nconst users = await User.find().where('firstName').equals('John');\n\n// finding all users\nconst users = await User.find();\n\n// creating a document\nconst user = new User({\n    firstName: 'John',\n    lastName: 'Doe'\n});\n\nuser.save();\n\n// updating a document\nawait User.findOneAndUpdate({ lastName: 'Doe' }, { firstName: 'Jane' });\n\n// deleting a document\nawait User\n    .findOneAndDelete({ lastName: 'Doe' });\n</code></pre> <ul> <li>Object Ids: Mongoose uses ObjectIds to uniquely identify documents in a collection. These are automatically generated when a new document is created.</li> </ul> <pre><code>const Model = mongoose.model('Test', schema);\n\nconst doc = new Model();\ndoc._id instanceof mongoose.Types.ObjectId; // true\n</code></pre> <ul> <li>Middleware: Mongoose middleware functions are functions that are executed before or after certain operations. They can be used to perform tasks like data validation, encryption, and more.</li> </ul> <pre><code>UserSchema.pre('save', function(next) {\n    // Perform some tasks before saving the document\n    next();\n});\n</code></pre>"},{"location":"sprint03/3-ORM%27s/ODM%20%28document%20DB%29/#useful-links","title":"Useful links","text":"<ul> <li>Mongoose documentation</li> <li>MongoDB documentation</li> </ul>"},{"location":"sprint03/3-ORM%27s/ORM%20%28relational%20DB%29/","title":"Definition &amp; Examples of ORM's","text":"<p>Object-Relational Mapping (ORM) is a programming technique that converts data between incompatible type systems using object-oriented programming languages. It creates a \"virtual object database\" that can be used within the programming language. ORM's are used to interact with relational databases, such as MySQL, PostgreSQL, and SQLite.</p> <p>Short: It does all the heavy lifting for you, so you don't have to write SQL queries by hand. It also provides a way to map your database tables to JavaScript objects, so you can work with them in a more object-oriented way.</p> <p>Some popular ORM's for Node.js are: - Sequelize - TypeORM - Prisma - (...)</p> <p>Here is an example of how you can use Sequelize to interact with a MySQL database:</p> <pre><code>const { Sequelize, DataTypes } = require('sequelize');\n\nconst sequelize\n    = new Sequelize\n    ('database', 'username', 'password', {\n        host: 'localhost',\n        dialect: 'mysql'\n    });\n\nconst User = sequelize.define('User', {\n    // Model attributes are defined here\n    firstName: {\n        type: DataTypes.STRING,\n        allowNull: false\n    },\n    lastName: {\n        type: DataTypes.STRING\n        // allowNull defaults to true\n    }\n});\n\n// fetching all users\nconst users = await User.findAll();\n\n// creating a new user\n\nconst user = await User.create({\n    firstName: 'John',\n    lastName: 'Doe'\n});\n\n// updating a user\n\nawait User.update({ firstName: 'Jane' }, {\n    where: {\n        lastName: 'Doe'\n    }\n});\n\n// deleting a user\n\nawait User.destroy({\n    where: {\n        lastName: 'Doe'\n    }\n});\n\n// syncing the model with the database\nawait sequelize.sync();\n</code></pre>"},{"location":"sprint03/3-ORM%27s/ORM%20%28relational%20DB%29/#core-concepts-in-sequelize","title":"Core concepts in Sequelize","text":"<ul> <li>Models: Models are JavaScript classes that represent database tables. They define the structure of the data that will be stored in the database. Example:</li> </ul> <p><pre><code>const User = sequelize.define('User', {\n    // Model attributes are defined here\n    firstName: {\n        type: DataTypes.STRING,\n        allowNull: false\n    },\n    lastName: {\n        type: DataTypes.STRING\n        // allowNull defaults to true\n    }\n});\n</code></pre> - Associations: Associations define the relationships between different models. For example, a user model might have an association with a post model, indicating that a user can have multiple posts.</p> <pre><code>// 1-to-many association\nUser.hasMany(Post);\nPost.belongsTo(User);\n\n// then querying the posts of a user would look like this:\nconst user = await User.findByPk(1);\nconst posts = await user.getPosts();\n\n// many-to-many association\nUser.belongsToMany(Project, { through: 'UserProject' });\nProject.belongsToMany(User, { through: 'UserProject' });\n\n// or with parameters\nconst UserProject = sequelize.define('UserProject', {\n    role: Sequelize.STRING\n});\n\nUser.belongsToMany(Project, { through: UserProject });\nProject.belongsToMany(User, { through: UserProject });\n\n// then querying the projects of a user would look like this:\nconst user = await User.findByPk(1);\nconst projects = await user.getProjects();\n\n\n\n// 1-to-1 association\nUser.hasOne(Profile);\nProfile.belongsTo(User);\n\n// self-association\nUser.belongsToMany(User, { as: 'Friends', through: 'Friendship' });\n</code></pre> <ul> <li> <p>Migrations: Migrations are scripts that define the structure of the database. They allow you to create, update, and delete tables and columns in the database.</p> </li> <li> <p>Queries: Queries are used to interact with the database. They allow you to fetch, create, update, and delete data in the database.</p> </li> </ul>"},{"location":"sprint03/3-ORM%27s/ORM%20%28relational%20DB%29/#useful-links","title":"Useful links:","text":"<ul> <li>Sequelize documentation</li> <li>TypeORM documentation</li> <li>Prisma documentation</li> <li>Node.js ORM comparison</li> </ul>"},{"location":"sprint04/","title":"Sprint goals","text":""},{"location":"sprint04/#dates","title":"Dates","text":"<p>From 10/04/2024 to 23/04/2024</p>"},{"location":"sprint04/#introduction","title":"Introduction","text":"<p>In this sprint, the groups of the CBL project have the following objectives:</p>"},{"location":"sprint04/#class-p1","title":"Class P1","text":"<ul> <li>Continue the development of the API, with the development of new functionalities and endpoints.</li> <li>Integration of improvements in the API, such as pagination, filters, and sorting.</li> <li>Error handling and input data validation.</li> <li>Define the final contract of the API so that it can be consumed by the UI layer.</li> </ul>"},{"location":"sprint04/#class-p2","title":"Class P2","text":"<ul> <li>Start the integration of the API in development:</li> <li>Understand how requests to the API work through the state manager (in this case, redux);</li> <li>Allow CRUD within the app;</li> <li>Continue interface improvements and feature development:<ul> <li>Accessibility with Storybook;</li> <li>Approach to unit tests for components.</li> </ul> </li> </ul>"},{"location":"sprint04/1-API-Optimizations/1-search/","title":"Search in a REST API","text":"<pre><code>GET /products?term=iphone\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/1-search/#introduction","title":"Introduction","text":"<p>In this document, we will discuss the importance of search functionality in REST APIs and how it can be implemented to optimize the performance of your API.</p>"},{"location":"sprint04/1-API-Optimizations/1-search/#why-is-search-important","title":"Why is search important?","text":"<p>Search functionality is a common requirement in many applications. It allows users to find specific information quickly and efficiently. Without search functionality, users would have to manually browse through large datasets to find the information they need.</p> <p>Imagine a scenario where a user wants to find a specific product in an e-commerce application. Without search functionality, the user would have to scroll through all the products to find the one they are looking for. This can be time-consuming and frustrating for the user.</p>"},{"location":"sprint04/1-API-Optimizations/1-search/#how-does-search-work","title":"How does search work?","text":"<p>Search functionality in REST APIs allows users to query the API for specific information based on search criteria. The API processes the search query and returns the relevant results to the user.</p>"},{"location":"sprint04/1-API-Optimizations/1-search/#implementing-search-in-expressjs","title":"Implementing search in Express.js","text":"<p>In Express.js applications, you can implement search functionality using query parameters. Here's an example of how you can implement search in an endpoint:</p>"},{"location":"sprint04/1-API-Optimizations/1-search/#simple-search-case","title":"Simple search case","text":"<pre><code>app.get('/products', (req, res) =&gt; {\n  // common query parameters for search: query, q, search, term,...\n  const { term } = req.query;\n\n  // Fetch products from the database based on the search query\n  const products = Products.find({\n    where: {\n      title: {\n        [Op.like]: `%${term}%`,\n      },\n    },\n  });\n\n  res.json(products);\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/1-search/#advanced-search-case-where-we-can-filter-by-multiple-fields","title":"Advanced search case where we can filter by multiple fields","text":"<pre><code>app.get('/products', (req, res) =&gt; {\n  // common query parameters for search: query, q, search, term,...\n  const { term } = req.query;\n\n\n  const products = Products.find({\n   where = {\n        [Op.or]: [\n            { name: { [Op.like]: `%${term}%` } },\n            { description: { [Op.like]: `%${term}%` } }\n        ]\n    }\n  });\n\n  res.json(products);\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/2-pagination/","title":"Pagination in REST API","text":"<pre><code>GET /products?offset=0&amp;limit=10\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/2-pagination/#introduction","title":"Introduction","text":"<p>In this document, we will discuss the importance of pagination in REST APIs and how it can be implemented to optimize the performance of your API.</p>"},{"location":"sprint04/1-API-Optimizations/2-pagination/#why-is-pagination-important","title":"Why is pagination important?","text":"<p>When working with large datasets, it is common to have a large number of records returned by an API endpoint. Returning all records at once can lead to performance issues, such as slow response times and high memory usage.</p> <p>Imagine fetching a list of 10,000 records from a database.</p> <ul> <li>The response would be large, which can lead to slow response times.</li> <li>The client may not need all 10,000 records at once, which can lead to unnecessary data transfer and mobile data usage.</li> <li>The server may run out of memory if it tries to load all 10,000 records into memory at once and process them.</li> </ul>"},{"location":"sprint04/1-API-Optimizations/2-pagination/#how-does-pagination-work","title":"How does pagination work?","text":"<p>Pagination is a technique used to break down large datasets into smaller, more manageable chunks. Instead of returning all records at once, the API returns a subset of records along with metadata that indicates the total number of records and the current page.</p>"},{"location":"sprint04/1-API-Optimizations/2-pagination/#types-of-pagination","title":"Types of pagination","text":"<p>There are two common types of pagination:</p> <ul> <li>Offset-based pagination: This type of pagination uses an offset and limit to determine which subset of records to return. For example, to fetch records 11-20, you would use an offset of 10 and a limit of 10.</li> </ul> <pre><code>GET /products?page=1&amp;limit=10\n</code></pre> <ul> <li>Cursor-based pagination: This type of pagination uses a cursor to determine the subset of records to return. The cursor is a unique identifier that points to a specific record in the dataset. For example, to fetch records after a specific record, you would use the cursor of that record.</li> </ul> <pre><code>GET /products?lastId=10&amp;limit=10\n</code></pre> <p>When to use offset-based pagination: - When the dataset has a stable order. - When you need to jump to a specific page.</p> <p>When to use cursor-based pagination: - When the dataset is frequently updated. - When you need to fetch records after a specific record.</p>"},{"location":"sprint04/1-API-Optimizations/2-pagination/#implementing-pagination-in-expressjs","title":"Implementing pagination in Express.js","text":"<p>In Express.js applications, you can implement pagination using query parameters. Here's an example of how you can implement offset-based pagination:</p>"},{"location":"sprint04/1-API-Optimizations/2-pagination/#offset-based-pagination","title":"Offset-based pagination","text":"<pre><code>app.get('/users', (req, res) =&gt; {\n  const { page = 1, limit = 10 } = req.query;\n\n  // if the limit is 10 then if we are in the 3rd page we should skip 20 records\n  const offset = (page - 1) * limit;\n\n  // page 1: offset = 0, limit = 10\n  // page 2: offset = 10, limit = 10\n\n  // Fetch records from the database using the offset and limit\n  const users = Users.findAll({ offset, limit });\n\n  res.json({\n    users,\n    page,\n    limit,\n  });\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/2-pagination/#cursor-based-pagination","title":"Cursor-based pagination","text":"<pre><code>app.get('/users', (req, res) =&gt; {\n  const { lastId, limit = 10 } = req.query;\n\n  // Fetch records from the database using the cursor and limit\n  const cursor = lastId || 0;\n    return await User.findAll({\n        limit: limit\n        where: {\n            id: {\n                [Op.gt]: cursor\n            }\n        }\n    });\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/2-pagination/#client-side-techniques","title":"Client side techniques","text":"<ul> <li>Paginated pages</li> <li>Infinite scrolling</li> <li>Load more button</li> </ul>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/","title":"Filtering and Sorting in a REST API","text":"<pre><code>GET /products?category=electronics&amp;minPrice=100&amp;maxPrice=500&amp;sortBy=price&amp;orderBy=asc\n</code></pre> <p>In this document, we will discuss the importance of filtering and sorting in REST APIs and how they can be implemented to optimize the performance of your API.</p>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#why-are-filtering-and-sorting-important","title":"Why are filtering and sorting important?","text":"<p>When working with large datasets, it is common to have a large number of records returned by an API endpoint. Filtering and sorting allow users to narrow down the results to only the data they need and to order the results in a specific way.</p> <p>Imagine fetching a list of products from an e-commerce application.</p> <ul> <li> <p>The user may want to filter the products by category, price range, or availability.</p> </li> <li> <p>The user may want to sort the products by price, rating, or popularity.</p> </li> </ul> <p>By providing filtering and sorting options, you can improve the user experience and make it easier for users to find the information they need.</p>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#filtering","title":"Filtering","text":""},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#how-does-filtering-work","title":"How does filtering work?","text":"<p>Filtering in REST APIs allows users to query the API for specific information based on filter criteria. The API processes the filter query and returns the relevant results to the user.</p>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#implementing-filtering-in-expressjs","title":"Implementing filtering in Express.js","text":"<p>In Express.js applications, you can implement filtering using query parameters. Here's an example of how you can implement filtering in an endpoint:</p>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#filtering-by-category","title":"Filtering by category","text":"<pre><code>app.get('/products', (req, res) =&gt; {\n  const { category } = req.query;\n\n  // Fetch products from the database based on the category filter\n  const products = Products.find({\n    where: {\n      category,\n    },\n  });\n\n  res.json(products);\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#filtering-by-price-range","title":"Filtering by price range","text":"<pre><code>app.get('/products', (req, res) =&gt; {\n  const { minPrice, maxPrice } = req.query;\n\n  // Fetch products from the database based on the price range filter\n  const products = Products.find({\n    where: {\n      price: {\n        [Op.gte]: minPrice,\n        [Op.lte]: maxPrice,\n      },\n    },\n  });\n\n  res.json(products);\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#advanced-filtering-case-where-we-can-filter-by-multiple-optional-fields","title":"Advanced filtering case where we can filter by multiple optional fields","text":"<pre><code>app.get('/products', (req, res) =&gt; {\n  const { category, minPrice, maxPrice } = req.query;\n\n    // Build the filter object based on the query parameters\n    const filter = {};\n    if (category) {\n        filter.category = category;\n    }\n    if (minPrice &amp;&amp; maxPrice) {\n        filter.price = {\n            [Op.gte]: minPrice,\n            [Op.lte]: maxPrice,\n        };\n    }\n\n    // Fetch products from the database based on the filter\n    const products = Products.find({\n        where: filter,\n    });\n\n    res.json(products);\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#lhs-brackets","title":"LHS Brackets","text":"<p>And although the previous presented solutions for filtering are perfectly fine, they are not very flexible. The filters above would only work for exact matches. The problem is that URL parameters only have a key and a value but filters can be composed of three components:</p> <p>The field name The operator The filter value LHS Brackets</p> <p>One solution to the problem is the use of LHS brackets which are composed in this way</p> <p><code>field[operator]=value</code></p> <p>For example, if we want to filter products with a price greater than 100, we would use the following URL parameter:</p> <p><code>/products?price[gte]=100</code></p> <p>This way, we can easily extend our filtering capabilities to include more complex filters.</p>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#implementing-lhs-brackets-in-expressjs","title":"Implementing LHS Brackets in Express.js","text":"<pre><code>// express.js uses the qs library to parse query strings\nconst qs = require('qs');\n\napp.get('/products', (req, res) =&gt; {\n  const filters = req.query;\n\n  // Express js does this behind the scenes\n  const filter = qs.parse('price[gte]=10&amp;price[lte]=100');\n\n  // filter will be { price: { gte: 10, lte: 100 } }\n\n  // Fetch products from the database based on the filter\n  const products = Products.find({\n    where: filter,\n  });\n\n  res.json(products);\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#how-does-sorting-work","title":"How does sorting work?","text":"<p>Sorting in REST APIs allows users to order the results based on a specific field or fields. The API processes the sort query and returns the results in the specified order.</p>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#implementing-sorting-in-expressjs","title":"Implementing sorting in Express.js","text":"<p>In Express.js applications, you can implement sorting using query parameters. Here's an example of how you can implement sorting in an endpoint:</p>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#sorting-by-a-single-field","title":"Sorting by a single field","text":"<pre><code>app.get('/products', (req, res) =&gt; {\n  const {     \n    sortBy = \"title\",\n    orderBy = \"asc\",\n  } = req.query;\n\n  // Fetch products from the database and sort them based on the sortBy parameter\n  const products = Products.find({\n    order: [[sort_by, order_by]],\n  });\n\n  res.json(products);\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/3-filtering%26sorting/#sorting-by-multiple-fields","title":"Sorting by multiple fields","text":"<pre><code>app.get('/products', (req, res) =&gt; {\n  const {     \n    sortBy = \"title,price\",\n    orderBy = \"asc, desc\",\n  } = req.query;\n\n  const sort_by = sortBy.split(',');\n  const order_by = orderBy.split(',');\n  const order = sort_by.map((field, index) =&gt; [field, order_by[index] || 'asc']);\n\n  // Fetch products from the database and sort them based on the sortBy parameter\n  const products = Products.find({\n    order,\n  });\n\n  res.json(products);\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/4-validations/","title":"User Input &amp; Validation in a REST API","text":"<pre><code>POST /users\nContent-Type: application/json\n\n{\n  \"name\": \"John Doe\",\n  \"email\": \"\n  \"password\": \"123456\"\n}\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/4-validations/#introduction","title":"Introduction","text":"<p>In this document, we will discuss the importance of user input validation in REST APIs.</p>"},{"location":"sprint04/1-API-Optimizations/4-validations/#why-is-user-input-validation-important","title":"Why is user input validation important?","text":"<p>User input validation is a crucial part of any application. It ensures that the data entered by the user is accurate, consistent, and secure.  By implementing user input validation, we also communicate to the consumer of the API what is expected in the request body, query parameters, or headers.</p> <p>Examples in a e-commerce application:  - When a user is creating an account, the API should validate the email, password, and other fields to ensure that the data is correct and secure. - When the user adds a product to the cart, the API should validate the product ID, quantity, and other parameters to ensure that the request is valid.</p>"},{"location":"sprint04/1-API-Optimizations/4-validations/#when-should-we-validate-user-input","title":"When should we validate user input?","text":"<p> should be performed at the earliest possible stage in the application flow.</p> <p>User input validation should be performed at the earliest possible stage in the application flow.</p> <ul> <li> <p>Client side validation: This is the first line of defense against invalid data. It can be done using JavaScript in the browser before the request is sent to the server.</p> </li> <li> <p>Server side validation: Even if client side validation is in place, server side validation is essential to ensure that the data is valid and secure. This is especially important when dealing with sensitive data or when the client-side validation can be bypassed.</p> </li> <li> <p>Built in db constraints: Database constraints can also be used to enforce data integrity. This can include constraints such as unique keys, foreign keys, and data types. In some dbs like mongodb, you can also define schema validation rules.</p> </li> </ul>"},{"location":"sprint04/1-API-Optimizations/4-validations/#setting-up-validation-using-expressjs","title":"Setting up validation using Express.js","text":"<p>In Express.js applications you can build your custom validation in your endpoints:</p> <pre><code>app.post('/users', (req, res) =&gt; {\n  const { name, email, password } = req.body;\n\n  // verification of required fields\n  if (!name || !email || !password) {\n    return res.status(400).json({ error: 'Missing required fields' });\n  }\n\n  // checking if it is a valid email\n  if (! /\\S+@\\S+\\.\\S+/.test(email)) {\n    return res.status(400).json({ error: 'Invalid email' });\n  }\n\n  // checking if the password has at least 6 characters\n  if (password.length &lt; 6) {\n    return res.status(400).json({ error: 'Password must have at least 6 characters' });\n  }\n\n  User.create({ name, email, password })\n\n});\n</code></pre> <p>This approach is simple and effective for basic validation. However, for more complex validation, you can use libraries like <code>express-validator</code> or <code>joi</code> to define validation schemas and rules.</p>"},{"location":"sprint04/1-API-Optimizations/4-validations/#using-express-validator","title":"Using express-validator","text":"<p>Express Validator is a set of middleware functions that wraps validator.js and provides a simple way to validate user input.</p> <p>You can check all the available validation methods in the documentation.</p> <pre><code>const { body, validationResult } = require('express-validator');\n\napp.post('/users', \n  body('email').isEmail().custom(async value =&gt; {\n    const user = await User.findUserByEmail(value);\n    if (user) {\n      throw new Error('E-mail already in use');\n    }\n  }),\n  body('password').isLength({ min: 6 }),\n  (req, res) =&gt; {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ errors: errors.array() });\n    }\n    // Continue with the request\n  }\n);\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/4-validations/#using-joi","title":"Using Joi","text":"<pre><code>const Joi = require('joi');\n\napp.post('/users', (req, res) =&gt; {\n  const schema = Joi.object({\n    email: Joi.string().email().required(),\n    password: Joi.string().min(6).required()\n  });\n\n  const { error } = schema.validate(req.body);\n  if (error) {\n    return res.status(400).json({ error: error.details[0].message });\n  }\n  // Continue with the request\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/4-validations/#using-zod","title":"Using Zod","text":"<pre><code>const { z } = require('zod');\n\napp.post('/users', (req, res) =&gt; {\n  const schema = z.object({\n    email: z.string().email(),\n    password: z.string().min(6)\n  });\n\n  try {\n    schema.parse(req.body);\n    // Continue with the request\n  } catch (error) {\n    return res.status(400).json({ error: error.errors });\n  }\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/5-response-normalization/","title":"Optimizing API Responses:","text":""},{"location":"sprint04/1-API-Optimizations/5-response-normalization/#what-is-response-normalization","title":"What is response normalization?","text":"<p>Response normalization in short is about making the API more readable and predictable for the client.</p> <p>Response normalization is the process of transforming the response data from an API into a consistent and structured format. This ensures that the response data is easy to work with and understand for clients consuming the API.</p> <p>In a REST API, response normalization typically involves formatting the data returned by the API endpoints in a consistent manner. This includes standardizing field names, data types, and structures across different endpoints.</p>"},{"location":"sprint04/1-API-Optimizations/5-response-normalization/#why-is-response-normalization-important","title":"Why is response normalization important?","text":"<p>Response normalization is important for several reasons:</p> <ul> <li> <p>Consistency: By normalizing the response data, you ensure that the API returns data in a consistent format. This makes it easier for clients to consume the API and work with the response data.</p> </li> <li> <p>Predictability: Clients can rely on the response data having a consistent structure, making it easier to parse and extract the information they need.</p> </li> <li> <p>Simplicity: Normalizing the response data simplifies the client-side code required to handle the API responses. Clients can expect a standard format for the data, reducing the complexity of the client-side logic.</p> </li> <li> <p>Maintainability: A normalized response format makes it easier to maintain and update the API over time. Changes to the data structure can be made consistently across all endpoints, reducing the risk of breaking client applications.</p> </li> </ul>"},{"location":"sprint04/1-API-Optimizations/5-response-normalization/#response-metadata","title":"Response metadata","text":"<p>In addition to the data returned by the API, response normalization often includes metadata that provides additional information about the response. This metadata can include details such as the status code, error messages, pagination information, and other relevant details.</p>"},{"location":"sprint04/1-API-Optimizations/5-response-normalization/#how-to-normalize-responses-in-a-rest-api","title":"How to normalize responses in a REST API","text":"<pre><code>function error(message, statusCode = 500, errors = []) {\n  return {\n    message,\n    code: statusCode,\n    meta: {\n      statusCode,\n      error: true,\n      errors,\n      ...meta,\n    },\n  };\n}\n\nfunction success(data, statusCode = 200, meta = {}) {\n  return {\n    data,\n    meta: {\n      statusCode,\n      error: false,\n      ...meta,\n    },\n  };\n}\n\napp.get('/users', (req, res) =&gt; {\n  const users = Users.findAll();\n  res.json(success(users));\n});\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/5-response-normalization/#response-patterns","title":"Response patterns","text":""},{"location":"sprint04/1-API-Optimizations/5-response-normalization/#success-response-in-a-normalized-format-with-pagination-information","title":"Success response in a normalized format with pagination information","text":"<pre><code>{\n    \"data\": [\n        {\n            \"id\": 1,\n            \"name\": \"John Doe\",\n            \"email\": \"john.doe@example.com\"\n        },\n        {\n            \"id\": 2,\n            \"name\": \"Jane Smith\",\n            \"email\": \"jane.smith@example.com\"\n        }\n    ],\n    \"meta\": {\n        \"statusCode\": 200,\n        \"error\": false,\n        \"pagination\": {\n            \"page\": 1,\n            \"limit\": 10,\n            \"total\": 100\n        }\n    }\n}\n</code></pre>"},{"location":"sprint04/1-API-Optimizations/5-response-normalization/#error-response-in-a-normalized-format","title":"Error response in a normalized format","text":"<pre><code>{\n  \"message\": \"Invalid request parameters\",\n  \"code\": 400,\n  \"meta\": {\n    \"statusCode\": 400,\n    \"error\": true,\n    \"errors\": [\n      {\n        \"field\": \"email\",\n        \"message\": \"Email is required\",\n      },\n      {\n        \"field\": \"password\",\n        \"message\": \"Password must be at least 6 characters\",\n      },\n    ],\n  }\n}\n\n```json\n{\n  \"message\": \"Internal server error\",\n  \"code\": 500,\n  \"meta\": {\n    \"statusCode\": 500,\n    \"error\": true,\n    \"errors\": [],\n  }\n}\n</code></pre>"},{"location":"sprint05/","title":"Sprint goals","text":""},{"location":"sprint05/#dates","title":"Dates","text":"<p>From 24/04/2024 to 14/05/2024 (3 weeks)</p>"},{"location":"sprint05/#introduction","title":"Introduction","text":"<p>In this sprint, the groups of the CBL project have the following objectives:</p>"},{"location":"sprint05/#class-p1","title":"Class P1","text":"<ul> <li>Develop the authentication and authorization layer of the project;</li> <li>Integrate the authentication logic with the existing API controllers and models;</li> <li>Integration of authentication providers (e.g., Google, Facebook, etc.);</li> <li>Finalize the authentication flow on the front-end according to the contract established in the API;</li> <li>Optimize or adapt the API responses based on the needs of pagination or filtering of listings;</li> <li>Continue the integration of the API with the front-end project.</li> </ul>"},{"location":"sprint05/#class-p2","title":"Class P2","text":"<ul> <li>Using the knowledge acquired in previous sprints regarding state managers (specifically, Redux), the objectives are:</li> <li>Study the implementation of the state manager in the project;</li> <li>Prepare the state manager for API integration (redux toolkit query);</li> <li>Study the API of the projects (structure of requests, structure of responses, etc.);</li> <li>Start integrating requests to the API.</li> </ul>"},{"location":"sprint05/Authentication/","title":"Authentication in RESTful APIs","text":""},{"location":"sprint05/Authentication/#but-first-the-register-endpoint-for-the-api","title":"But first, the /register endpoint for the API","text":"<p>Before having to deal with authentication, we need to have a way to register users in the system. This is done through the <code>/register</code> endpoint. The endpoint is a POST request that receives a JSON object with the following structure:</p> <pre><code>{\n    \"username\": \"user\",\n    \"password\": \"password\"\n}\n</code></pre> <p>In order to safeguard the passwords, they should be hashed before being stored in the database. The hashing algorithm used should be a secure one, such as bcrypt. The password should be hashed before being stored in the database.</p>"},{"location":"sprint05/Authentication/#simple-example-of-how-to-hash-a-password-using-bcrypt","title":"Simple example of how to hash a password using bcrypt","text":"<pre><code>const bcrypt = require('bcrypt');\n\nconst password = 'password';\nconst saltRounds = 10;\n\n// register endpoint\nbcrypt\n  .hash(password, saltRounds)\n  .then(hash =&gt; {\n    console.log('Hash ', hash)\n  })\n\n// login endpoint\nfunction validateUser(storedPasswordHash, insertedPassword) {\n    bcrypt\n        .compare(insertedPassword, storedPasswordHash)\n        .then(res =&gt; {\n            // handle Authentication\n        })\n        .catch(err =&gt; console.error(err.message))        \n}\n</code></pre> <p>Bcrypt is a library that allows you to hash passwords using a secure algorithm. The <code>hash</code> function receives the password, the number of salt rounds, and a callback function. The callback function will receive an error if the hashing process fails, or the hashed password if it succeeds.</p> <p>The number of salt rounds is a parameter that determines the complexity of the hashing algorithm. The higher the number of rounds, the more secure the hash will be, but it will also take longer to compute. A common value for the number of rounds is 10.</p> <p>How bycrypt works is that it generates a random salt for each password, and then hashes the password with the salt. This way, even if two users have the same password, their hashes will be different.</p>"},{"location":"sprint05/Authentication/#introduction","title":"Introduction","text":"<p>This document explores various methods for authenticating users in RESTful APIs, detailing the implementation and security considerations for each authentication strategy.</p>"},{"location":"sprint05/Authentication/#stateless-nature-of-restful-apis","title":"Stateless Nature of RESTful APIs","text":"<p>RESTful APIs are designed to be stateless, meaning the server does not retain any client state between requests. As such, each client request must include all necessary data for processing, including authentication details to verify the user's identity.</p>"},{"location":"sprint05/Authentication/#user-authentication-overview","title":"User Authentication Overview","text":"<p>User authentication is crucial for any system requiring secure access to resources. This document outlines several common authentication methods used in RESTful APIs:</p> <ol> <li>Basic Authentication</li> <li>API Key Authentication</li> <li>Token-based Authentication (Bearer Token)</li> <li>Cookie-based Authentication (Session-based)</li> </ol>"},{"location":"sprint05/Authentication/#basic-authentication","title":"Basic Authentication","text":"<p>Basic Authentication transmits credentials (username and password) with every request, typically encoded in base64. Due to the exposure of credentials in plain text, it should only be used over HTTPS to ensure encryption.</p>"},{"location":"sprint05/Authentication/#when-to-use","title":"When to Use","text":"<ul> <li>Internal, low-security APIs</li> <li>Non-sensitive data access</li> <li>Development and testing environments</li> </ul>"},{"location":"sprint05/Authentication/#advantages","title":"Advantages","text":"<ul> <li>Simple to implement</li> <li>Immediate compatibility with most HTTP clients</li> </ul>"},{"location":"sprint05/Authentication/#disadvantages","title":"Disadvantages","text":"<ul> <li>Low security, as credentials are easily exposed</li> <li>Not suitable for production environments with sensitive data</li> </ul>"},{"location":"sprint05/Authentication/#implementation-guidelines","title":"Implementation Guidelines","text":"<p>Include credentials in the HTTP <code>Authorization</code> header, encoded in base64. The server should decode and validate these credentials against its database or authentication service:</p> <pre><code>GET /api/resource \nHost: example.com\nAuthorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\n</code></pre> <p>Server-side pseudocode:</p> <pre><code>const authHeader = req.headers.authorization;\nconst credentials = Buffer.from(authHeader.split(' ')[1], 'base64').toString().split(':');\nconst [username, password] = credentials;\n\nif (username === storedUsername &amp;&amp; password === storedPassword) {\n    // User authenticated\n} else {\n    // Authentication failed, send 401 Unauthorized\n}\n</code></pre>"},{"location":"sprint05/Authentication/#api-key-authentication","title":"API Key Authentication","text":"<p>API Key Authentication uses a unique key provided to each user, offering a more secure alternative to basic authentication without requiring direct user credentials.</p>"},{"location":"sprint05/Authentication/#when-to-use_1","title":"When to Use","text":"<ul> <li>Public APIs</li> <li>Systems needing user-specific access without direct credentials</li> </ul>"},{"location":"sprint05/Authentication/#advantages_1","title":"Advantages","text":"<ul> <li>More secure than Basic Authentication</li> <li>Simplifies controlling and tracking API usage</li> </ul>"},{"location":"sprint05/Authentication/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>Management overhead for API keys</li> <li>Potential security risks if keys are exposed</li> </ul>"},{"location":"sprint05/Authentication/#implementation-guidelines_1","title":"Implementation Guidelines","text":"<p>API keys can be sent as custom headers or query parameters. The server should validate each key against its database:</p> <pre><code>GET /api/resource\nHost: example.com\nX-API-Key: your_api_key\n</code></pre> <p>Server-side pseudocode:</p> <pre><code>const apiKey = req.headers['x-api-key'];\nif (apiKey === storedApiKey) {\n    // User authenticated\n} else {\n    // Authentication failed, send 401 Unauthorized\n}\n</code></pre>"},{"location":"sprint05/Authentication/#token-based-authentication-bearer-token","title":"Token-based Authentication (Bearer Token)","text":"<p>Token-based Authentication, particularly using JSON Web Tokens (JWT), offers a secure and scalable method to authenticate users and sessions.</p>"},{"location":"sprint05/Authentication/#when-to-use_2","title":"When to Use","text":"<ul> <li>Applications requiring high security</li> <li>Services providing stateless authentication</li> </ul>"},{"location":"sprint05/Authentication/#advantages_2","title":"Advantages","text":"<ul> <li>High security as tokens can encode user information and permissions</li> <li>Scalable and suitable for distributed systems</li> </ul>"},{"location":"sprint05/Authentication/#disadvantages_2","title":"Disadvantages","text":"<ul> <li>Complexity in token management and expiration</li> <li>Requires secure transmission mechanisms</li> </ul>"},{"location":"sprint05/Authentication/#using-jwts-for-token-based-authentication","title":"Using JWT's for Token-based Authentication","text":"<p>JWTs are self-contained tokens that can encode user information and permissions. They consist of three parts: a header, payload, and signature. The server signs the token with a secret key to verify its authenticity.</p>"},{"location":"sprint05/Authentication/#implementation-guidelines_2","title":"Implementation Guidelines","text":"<ol> <li>User Authentication: After successful login, generate a JWT containing user information and permissions:</li> </ol> <pre><code>const jwt = require('jsonwebtoken');\n\nconst generateAuthToken = (user) =&gt; {\n  const payload = {\n    id: user.id,\n    email: user.email,\n    role: user.role,\n  };\n\n  return jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1h' });\n};\n\napp.post('/login', (req, res) =&gt; {\n  const { email, password } = req;\n\n  const user = await UserModel.findByEmail(email);\n\n  const isPwValid = await user.validatePassword(password);\n\n  if (!isPwValid) throw UnauthorizedError();\n\n  res.json(\n    success(user, {\n      token: generateAuthToken(user),\n    })\n  );\n});\n</code></pre> <ol> <li>Token Verification: Middleware to verify the token before processing requests:</li> </ol> <pre><code>const jwt = require('jsonwebtoken');\n\nconst authMiddleware = (req, res, next) =&gt; {\n  const token = req.headers.authorization.split(' ')[1];\n\n  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) =&gt; {\n    if (err) return res.status(401).json({ message: 'Unauthorized' });\n\n    req.user = decoded;\n    next();\n  });\n};\n\napp.get('/api/resource', verifyToken, (req, res) =&gt; {\n  res.json({ message: 'Protected Resource' });\n});\n</code></pre>"},{"location":"sprint05/Authentication/#cookie-based-authentication-session-based","title":"Cookie-based Authentication (Session-based)","text":"<p>Cookie-based Authentication manages sessions using tokens stored in cookies, ideal for applications where user sessions are common.</p>"},{"location":"sprint05/Authentication/#when-to-use_3","title":"When to Use","text":"<ul> <li>Web applications with user sessions</li> <li>Environments where persistent state is beneficial</li> </ul>"},{"location":"sprint05/Authentication/#advantages_3","title":"Advantages","text":"<ul> <li>Seamless integration with web browsers</li> <li>Enhanced security through HTTP-only and Secure flags in cookies</li> </ul>"},{"location":"sprint05/Authentication/#disadvantages_3","title":"Disadvantages","text":"<ul> <li>Vulnerability to cross-site request forgery (CSRF)</li> <li>Requires careful session management</li> </ul>"},{"location":"sprint05/Authentication/#implementation-guidelines_3","title":"Implementation Guidelines","text":"<p>Sessions are typically managed with middleware like <code>express-session</code> in Node.js. The session ID is stored in a cookie:</p> <pre><code>GET /api/resource\nHost: example.com\nCookie: sessionId=your_session_id\n</code></pre> <p>Server-side pseudocode using <code>express-session</code>:</p> <pre><code>const express = require('express');\nconst session = require('express-session');\nconst User = require('./models/User');\n\napp.use(session({\n    secret: 'secret_key',\n    resave: false,\n    saveUninitialized: true,\n    cookie: { secure: true, httpOnly: true }\n}));\n\napp.post('/login', (req, res) =&gt; {\n    const { username, password } = req.body;\n\n    const user = User.findByUsername(username);\n\n    const isPwValid = await user.validatePassword(password);\n\n    if (!isPwValid) throw UnauthorizedError();\n\n    req.session.user = username;\n    res.send('Logged in!');\n});\n</code></pre>"},{"location":"sprint05/Authentication/#conclusion","title":"Conclusion","text":"<p>This document has detailed various authentication strategies for RESTful APIs, highlighting their usage scenarios, advantages, and implementation guidelines. The choice of authentication method depends on the specific security and operational requirements of each application.</p>"},{"location":"sprint05/Authorization/","title":"Authorization in RESTful APIs","text":""},{"location":"sprint05/Authorization/#introduction","title":"Introduction","text":"<p>Authorization is a critical component in securing RESTful APIs, ensuring that users have the correct permissions to access or perform actions on resources. Role-Based Access Control (RBAC) is widely used for efficient permission management across diverse systems.</p>"},{"location":"sprint05/Authorization/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"<p>RBAC governs access to resources based on the roles assigned to users. Each role is associated with a set of permissions that define allowable actions on resources. This approach streamlines access management and restricts users to operations essential for their role.</p>"},{"location":"sprint05/Authorization/#example-in-expressjs","title":"Example in Express.js","text":"<p>The following Express.js application demonstrates a practical implementation of RBAC:</p> <pre><code>const express = require('express');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\n\nconst users = [\n  { id: 1, name: 'Alice', role: 'admin' },\n  { id: 2, name: 'Bob', role: 'user' },\n];\n\n// Middleware to authenticate and populate req.user with user data\napp.use((req, res, next) =&gt; {\n  const token = req.headers['Authorization']?.split(' ')[1];\n  if (token) {\n    try {\n      const decoded = jwt.verify(token, 'your_secret_key');\n      req.user = users.find(user =&gt; user.id === decoded.id);\n      next();\n    } catch (error) {\n      return res.status(403).json({ message: 'Invalid token' });\n    }\n  } else {\n    return res.status(401).json({ message: 'No token provided' });\n  }\n});\n\n// Authentication middleware\nconst authenticate = (req, res, next) =&gt; {\n  if (!req.user) {\n    return res.status(401).json({ message: 'Unauthorized' });\n  }\n  next();\n};\n\n// Role checking middleware to enforce access control\nconst roleCheck = (role) =&gt; {\n  return (req, res, next) =&gt; {\n\n    if(!req.user) return res.status(401).json({ message: 'Unauthorized' };\n\n    if (req.user.role === role) {\n      next();\n    } else {\n      return res.status(403).json({ message: 'Access denied' });\n    }\n  };\n};\n\napp.get('/admin-protected-route', authMiddleware, roleCheck('admin'), (req, res) =&gt; {\n  res.json(users);\n});\n\napp.listen(3000, () =&gt; {\n  console.log('Server running on port 3000');\n});\n</code></pre> <p>This setup validates user tokens and applies role-based access control, restricting the <code>/users</code> endpoint to administrators.</p>"},{"location":"sprint05/Authorization/#using-custom-middleware","title":"Using Custom Middleware","text":"<p>Custom middleware can streamline the enforcement of role-based access:</p> <pre><code>const checkRole = role =&gt; (req, res, next) =&gt; {\n  if (req.user.role !== role) {\n    return res.status(403).json({ message: 'Access denied' });\n  }\n  next();\n};\n\napp.get('/users', authenticate, checkRole('admin'), (req, res) =&gt; {\n  res.json(users);\n});\n</code></pre> <p>This modular approach allows easy integration and reuse of authorization checks across multiple routes.</p>"},{"location":"sprint05/Authorization/#using-a-library","title":"Using a Library","text":"<p>For more complex scenarios, the <code>express-jwt-permissions</code> library offers a robust solution for implementing RBAC:</p> <pre><code>const express = require('express');\nconst guard = require('express-jwt-permissions')();\n\nconst app = express();\n\napp.get('/approve-product', guard.check(['approve-product']), (req, res) =&gt; {\n  res.json(users);\n});\n\napp.listen(3000, () =&gt; {\n  console.log('Server running on port 3000');\n});\n</code></pre> <p>The library simplifies permission checks, verifying if the user's JWT contains the required roles before granting access to specific endpoints.</p>"},{"location":"sprint05/Authorization/#conclusion","title":"Conclusion","text":"<p>RBAC is an efficient and secure method to manage permissions in REST APIs. By assigning roles to users and permissions to roles, it ensures that access is appropriately restricted. With the integration of specialized libraries, implementing RBAC in Express.js applications can be significantly simplified, enhancing security and manageability.</p>"},{"location":"sprint05/Oauth/","title":"OAuth","text":""},{"location":"sprint05/Oauth/#brief-history","title":"Brief history","text":"<p>Before OAuth, when you wanted to use an application to access your data, you had to give it your username and password. This was a bad idea for a number of reasons:</p> <ul> <li>The application could do anything it wanted with your data.</li> <li>The application could do anything it wanted with your account.</li> <li>The application could do anything it wanted with your friends' data.</li> </ul> <p>The applications like facebook, twitter, google, ... were not happy with this situation. They wanted to provide a way for users to give an application permission to access their data without giving the application their password. Each of them started to develop their own way to do this, but they all had the same basic idea: the user would give the application a token that the application could use to access the user's data.</p> <p>After a while, the people at Twitter, Google, and other companies got together and decided to create a standard way to do this. They called it OAuth.</p>"},{"location":"sprint05/Oauth/#oauth-10","title":"OAuth 1.0","text":"<p>In 2007, OAuth 1.0 was released. It was a good start, but it had some problems: - It was complicated (for devices) - Wasn't very secure on mobile devices.</p>"},{"location":"sprint05/Oauth/#oauth-20","title":"OAuth 2.0","text":"<p>In 2012, OAuth 2.0 was released. It was a big improvement over OAuth 1.0. It was simpler, more flexible, and more secure. It was also designed to work better on mobile devices.</p>"},{"location":"sprint05/Oauth/#oauth-and-openid-connect","title":"OAuth and OpenID Connect","text":"<p>OAuth and OpenId Connect are two different protocols that are often used together. OAuth is used to give an application permission to access a user's data, while OpenID Connect is used to authenticate a user.</p> <p>OAuth was originally designed for authorization, not authentication. All the user needs is a token that the application can use to access their data. If the application wants to know who the user is, it has to ask the user and there's where OpenID Connect comes in.</p> <p>OpenID Connect is built on top of OAuth. It adds a few extra steps to the OAuth process to allow the application to get information about the user, such as their name and email address.</p> <p>OAuth emits access tokens to the apps, while OpenID Connect emits ID (identity) tokens to the apps.</p>"},{"location":"sprint05/Oauth/#roles-in-oauth","title":"Roles in OAuth","text":"<ul> <li>Users (Resource owner) - person with the account</li> <li>Device (User Agent) - the device that the user is using to access the application (phone, pc, ...)</li> <li>The Application (Oauth client) - the application that the user wants to access the server </li> <li>Authorization server - the authentication server that the user logs in to</li> <li>Resource server - the server that has the user's data</li> </ul> <p>The user will never give their password to the application. Instead, the application will ask the user to log in to the API and give the application a token that the application can use to access the user's data.</p>"},{"location":"sprint05/Oauth/#client-types","title":"Client types","text":"<ul> <li>Confidential clients - can keep their client secret confidential</li> <li>Public clients - cannot keep their client secret confidential</li> </ul> <p>Confidental clients have a client secret that they use to authenticate with the authorization server. Public clients do not have a client secret, so they use a different method to authenticate with the authorization server.</p> <p>In single page applications, the client is public because the client secret can be easily extracted from the code. So the client uses the implicit flow to get the access token.</p>"},{"location":"sprint05/Oauth/#oauth-flows","title":"OAuth flows","text":"<ul> <li>Abstract Protocol Flow</li> <li>Implicit flow</li> <li>Resource owner password credentials flow (Password grant)</li> </ul>"},{"location":"sprint05/Oauth/#oauth-20-abstract-protocol-flow","title":"OAuth 2.0 Abstract Protocol Flow","text":"<p>The OAuth 2.0 protocol flow has the following steps:</p> <ol> <li>The application redirects the user to the authorization server.</li> <li>The user logs in to the authorization server.</li> <li>The authorization server redirects the user back to the application with an authorization code.</li> <li>The application sends the authorization code to the authorization server.</li> <li>The authorization server sends the access token to the application.</li> </ol>"},{"location":"sprint05/Oauth/#oauth-20-implicit-flow","title":"OAuth 2.0 Implicit Flow","text":"<p>The Implicit flow is used by single page applications that are hosted on a client. The flow has the following steps:</p> <ol> <li>The application redirects the user to the authorization server.</li> <li>The user logs in to the authorization server.</li> <li>The authorization server redirects the user back to the application with an access token.</li> <li>The application uses the access token to access the user's data.</li> </ol>"},{"location":"sprint05/Oauth/#oauth-20-resource-owner-password-credentials-flow","title":"OAuth 2.0 Resource Owner Password Credentials Flow","text":"<p>The Resource Owner Password Credentials flow is used by applications that have a high level of trust with the user. Was a real need in the past where CORS was not a thing and the application was the only one that could access the server. The flow has the following steps:</p> <ul> <li>The application asks the user for their username and password.</li> <li>The application sends the username and password to the authorization server.</li> <li>The authorization server sends the access token to the application.</li> <li>The application uses the access token to access the user's data.</li> </ul>"},{"location":"sprint05/Oauth/#security-note","title":"Security note","text":"<p>The Implicit flow is not as secure as the Abstract Protocol Flow because the access token is sent to the application in the URL. This means that the access token can be intercepted and used by an attacker.</p> <p>The password grant flow is also highly discouraged because the application has access to the user's password and needs to communicate it to the authorization server via the URL.</p>"},{"location":"sprint05/Oauth/#oauth-20-tokens","title":"OAuth 2.0 Tokens","text":"<ul> <li>Access token - used by the application to access the user's data</li> <li>Refresh token - used by the application to get a new access token</li> </ul> <p>The access token is a short-lived token that the application uses to access the user's data. The refresh token is a long-lived token that the application uses to get a new access token when the access token expires.</p>"},{"location":"sprint05/Oauth/#oauth-20-scopes","title":"OAuth 2.0 Scopes","text":"<p>Scopes are used to limit the access that the application has to the user's data. The application can request one or more scopes when it redirects the user to the authorization server. The authorization server will only give the application access to the user's data if the user has granted the application the requested scopes.</p>"},{"location":"sprint05/Oauth/#steps-to-implement-oauth","title":"Steps to implement OAuth","text":""},{"location":"sprint05/Oauth/#register-the-application-with-the-authorization-server-developers-application","title":"Register the application with the authorization server (developers application)","text":"<p>The first step is to register the application with the authorization server. This involves creating an account with the authorization server and creating an application with the authorization server. The application will be given a client ID and a client secret that it can use to authenticate with the authorization server.</p>"},{"location":"sprint05/Oauth/#redirect-the-user-to-the-authorization-server","title":"Redirect the user to the authorization server","text":"<p>The next step is to redirect the user to the authorization server. This involves sending the user to a URL that the authorization server provides. The URL will include the client ID, the scopes that the application is requesting, and a redirect URI that the authorization server will redirect the user back to after they have logged in.</p>"},{"location":"sprint05/Oauth/#the-user-logs-in-to-the-authorization-server","title":"The user logs in to the authorization server","text":"<p>The user will be asked to log in to the authorization server. This involves entering their username and password.</p>"},{"location":"sprint05/Oauth/#the-authorization-server-redirects-the-user-back-to-the-application","title":"The authorization server redirects the user back to the application","text":"<p>After the user has logged in, the authorization server will redirect the user back to the application with an authorization code.</p>"},{"location":"sprint05/Oauth/#the-application-sends-the-authorization-code-to-the-authorization-server","title":"The application sends the authorization code to the authorization server","text":"<p>The application will send the authorization code to the authorization server. The authorization server will verify the authorization code and send the access token to the application.</p>"},{"location":"sprint05/Oauth/#the-application-uses-the-access-token-to-access-the-users-data","title":"The application uses the access token to access the user's data","text":"<p>The application will use the access token to access the user's data. The access token will be included in the HTTP headers of the request that the application sends to the resource server.</p>"},{"location":"sprint05/Oauth/#the-application-uses-the-refresh-token-to-get-a-new-access-token","title":"The application uses the refresh token to get a new access token","text":"<p>When the access token expires, the application will use the refresh token to get a new access token. The refresh token will be included in the request that the application sends to the authorization server to get a new access token.</p>"},{"location":"sprint05/Oauth/#pratical-example-with-nextjs-passport-and-facebook-login-returning-jwt-token","title":"Pratical example with nextJS passport and facebook login returning jwt token","text":""},{"location":"sprint05/Oauth/#install-the-dependencies","title":"Install the dependencies","text":"<pre><code>npm install assport passport-facebook jsonwebtoken\n</code></pre> <pre><code>const passport = require('passport');\nconst FacebookStrategy = require('passport-facebook');\nconst jwt = require('jsonwebtoken');\n\npassport.use(new FacebookStrategy({\n  clientID: process.env.FACEBOOK_APP_ID,\n  clientSecret: process.env.FACEBOOK_APP_SECRET,\n  callbackURL: process.env.FACEBOOK_CALLBACK_URL,\n  profileFields: ['email']\n}, function(accessToken, refreshToken, profile, done) {\n    // this function is called when the user logs in with Facebook and the user's profile is returned\n\n    const {\n        email,\n    } = profile;\n\n    // find the user in the database\n    const user Users.find({ email });\n\n    const payload = {\n        id: user.id,\n        email: user.email,\n        role: user.role,\n    };\n\n    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1h' });\n    done(null, user);\n}));\n\nroutes.get('/auth/facebook', passport.authenticate('facebook', { scope: ['email'] }));\n\nroutes.get('/auth/facebook/callback', passport.authenticate('facebook', { session: false }), (req, res) =&gt; {\n    res.json({ token: req.user });\n});\n</code></pre>"},{"location":"sprint05/OpenId/","title":"OpenId Connect","text":"<p>OpenID Connect is a protocol that is built on top of OAuth 2.0. It adds a few extra steps to the OAuth process to allow the application to get information about the user, such as their name and email address.</p> <p>OAuth emits access tokens to the apps, while OpenID Connect emits ID (identity) tokens to the apps.</p>"},{"location":"sprint05/OpenId/#id-token","title":"ID Token","text":"<p>The ID token is a JSON Web Token (JWT) that contains information about the user. The ID token is signed by the authorization server, so the application can verify that the token is valid.</p> <p>The ID token contains information such as:</p> <ul> <li>sub - The user's unique identifier</li> <li>The user's name</li> <li>The user's email address</li> <li>The issuer of the token </li> <li>The audience of the token</li> <li>The expiration time of the token</li> <li>The time the token was issued</li> <li>The nonce value</li> </ul>"},{"location":"sprint05/OpenId/#openid-scopes","title":"OpenID scopes","text":"<p>OpenID Connect defines a set of scopes that the application can request when it redirects the user to the authorization server. The scopes define the information that the application wants to get about the user.</p> <p>The scopes are:</p> <ul> <li>openid - This scope is required for OpenID Connect</li> <li>profile - This scope requests the user's profile information, such as their name and email address</li> <li>email - This scope requests the user's email address</li> <li>address - This scope requests the user's address</li> <li>phone - This scope requests the user's phone number</li> </ul>"},{"location":"sprint06/FileUpload/","title":"File Upload","text":"<p>When dealing with file uploads in a web application, it's important to understand both the client-side and server-side processes. Below is a detailed explanation of how files are sent to the API and stored on the server, along with the data storage mechanisms involved.</p> <p>There are a few ways of storing files in a web application, such as storing them in a database, storing them in a file system, or storing them in a cloud storage service like Amazon S3 or Google Cloud Storage.</p> <p>Storing files in a database is not recommended for large files or high volumes of files, as it can lead to performance issues and increased storage costs as the database grows.</p> <p>In this lesson, we will focus on storing files in a file system, as it is the most common approach for small to medium-sized applications.</p>"},{"location":"sprint06/FileUpload/#process-of-sending-files-to-the-api-and-storing-them-in-the-file-system","title":"Process of sending files to the API and storing them in the file system","text":""},{"location":"sprint06/FileUpload/#client-side-process-example-with-react","title":"Client-side process (example with React)","text":"<p>Web applications can receive various types of input from users. From text fields, checkboxes, images, videos, etc... Usually, these forms are submitted to the server in various ways, including the structure of a JSON as discussed up to the current lesson. However, when submitting files to the server, this type of structure is not appropriate since files are not alphanumeric.</p> <p>As such, the multipart/form-data content type is used, which allows the processing of binary data (such as images).</p>"},{"location":"sprint06/FileUpload/#create-an-html-form-with-a-file-input-field-example-with-react-and-an-express-api","title":"Create an HTML form with a file input field (example with react and an express API)","text":"<p>The first step in uploading a file is to create an HTML form that includes a file input field. This field allows the user to select a file from their local machine.</p> <pre><code>import React, { useState } from 'react';\n\nconst FileUpload = () =&gt; {\n  const [file, setFile] = useState(null);\n\n  const handleFileChange = (e) =&gt; {\n    setFile(e.target.files[0]);\n  };\n\n  const handleSubmit = async () =&gt; {\n    const formData = new FormData();\n    formData.append('file', file);\n\n    // any additional data can be appended to the form data\n    // formData.append('name', 'desired_file_name');\n\n    const response = await fetch('http://localhost:3000/upload', {\n      method: 'POST',\n      body: formData,\n      headers: {\n        'Content-Type': 'multipart/form-data',\n      },\n    });\n\n    const data = await response.json();\n    console.log(data);\n  };\n\n  return (\n    &lt;form onSubmit={handleSubmit}&gt;\n      &lt;input type=\"file\" onChange={handleFileChange} /&gt;\n      &lt;button type=\"submit\"&gt;Upload&lt;/button&gt;\n    &lt;/form&gt;\n  );\n};\n</code></pre>"},{"location":"sprint06/FileUpload/#server-side-process-example-with-express","title":"Server side process (example with express)","text":"<p>On the server side, the file is received as a binary stream and stored in a temporary location. The server then needs to process the file and saves it to a permanent location.</p> <p>Currently, our API's are only able to receive JSON data as we only integrated the JSON middleware. To handle file uploads, we need to use a middleware that can handle multipart/form-data.</p> <p>Multer is a popular middleware for handling file uploads in Node.js. It allows you to upload files to the server and provides various options for file handling, such as renaming files, setting file size limits, and filtering file types.</p>"},{"location":"sprint06/FileUpload/#install-multer","title":"Install Multer","text":"<p>To use Multer in your Express application, you need to install it using npm or yarn. Additionally, you can install the <code>uuid</code> package to generate unique filenames for the uploaded files.</p> <pre><code>npm install multer uuid\n</code></pre>"},{"location":"sprint06/FileUpload/#configure-multer","title":"Configure Multer","text":"<p>After installing Multer, you need to configure it in your Express application. You can set the destination and filename for the uploaded files, as well as other options.</p> <p>Usually the filenames should be unique to avoid conflicts when multiple users upload files with the same name. You can use the <code>uuid</code> package to generate unique filenames. Adittionally, by having random filenames, you can avoid some security issues like path traversal attacks.</p> <p>For the folder where the files will be stored, you can use the <code>path</code> module to create a path relative to the root of the project. This way, you can ensure that the files are stored in a secure location.</p> <pre><code>const express = require('express');\nconst multer = require('multer');\nconst uuid = require('uuidv4');\nconst mime = require('mime-types');\n\nconst app = express();\n\n// Step 1: defining \nconst storage = multer.diskStorage({\n  destination: function (req, file, cb) {\n    cb(null, 'uploads/');\n  },\n  filename: function (req, file, cb) {\n    const uniqueSuffix = uuid();\n    const {\n      originalname,\n      mimetype\n    } = file;\n\n    // you can use the mime-types package to get the file extension\n    const extension = mime.extension(mimetype);\n    cb(null, `${uniqueSuffix}.${extension}`);\n  },\n});\n\nconst upload = multer({ storage: storage });\n\n// Step 2: defining the route ()\napp.post('/upload-avatar', upload.single('file'), (req, res) =&gt; {\n    // access the stored file path to store it in the database\n    const filePath = req.file.path;\n    // any additional data can be accessed from the request body\n    const { name } = req.body;\n\n    const { user } = req;\n\n    // example with a user avatar\n    await jane.update({ avatar: filePath });\n\n    await jane.save();\n\n    res.json({ message: 'File uploaded successfully' });\n});\n\n\n// Step 3: exposing the static folder\napp.use('/uploads', express.static('uploads'));\n\napp.listen(3000, () =&gt; {\n  console.log('Server running on port 3000');\n});\n</code></pre> <p>In the example above, we defined a storage configuration for Multer that specifies the destination folder and filename for the uploaded files. The <code>upload.single('file')</code> middleware is used to handle a single file upload with the field name 'file'.</p> <p>After the file is uploaded, the server responds with a JSON message indicating that the file was uploaded successfully.</p>"},{"location":"sprint06/FileUpload/#using-the-image-on-the-client-side","title":"Using the image on the client side","text":"<p>After the file is uploaded to the server, you can access it using the URL provided by the server. In the example above, we exposed the <code>/uploads</code> folder as a static directory, so the uploaded files can be accessed directly from the client side.</p> <p>As the base url of the API changes from development to production, it is recommended to store the base url in an environment variable.</p> <pre><code>const storageBaseUrl = process.env.STORAGE_BASE_URL || 'http://localhost:3000';\n\nconst imageUrl = `${storageBaseUrl}/uploads/${fileName}`;\n</code></pre> <p>By using the <code>storageBaseUrl</code> variable, you can ensure that the image URLs are generated correctly in different environments.</p>"},{"location":"sprint06/FileUpload/#process-of-storing-files-in-a-cloud-storage-service-provider","title":"Process of storing files in a cloud storage service provider","text":"<p>Storing files in a cloud storage service provider like Amazon S3 or Google Cloud Storage offers several advantages over storing files in a file system on the server.</p> <p>Cloud storage services provide scalable and reliable storage solutions with high availability and durability. They also offer features like versioning, encryption, and access control to secure your data.</p>"},{"location":"sprint06/FileUpload/#storing-files-in-google-cloud-storage","title":"Storing files in Google cloud storage","text":"<p>Step 1: Install the necessary dependencies</p> <p>To store files in Google Cloud Storage, you need to install the <code>@google-cloud/storage</code> package.</p> <pre><code>npm install @google-cloud/storage multer uuid\n</code></pre> <p>Step 2: Configure Google Cloud Storage</p> <p>After installing the necessary packages, you need to configure Google Cloud Storage in your Express application. You can create a new bucket in Google Cloud Storage and set up the necessary credentials to access the bucket.</p> <p>.env file <pre><code>GOOGLE_CLOUD_PROJECT_ID=your-project-id\nGOOGLE_CLOUD_STORAGE_BUCKET=your-bucket-name\nGOOGLE_CLOUD_STORAGE_KEYFILE=credentials.json # this \n</code></pre></p> <pre><code>const express = require('express');\nconst mime = require('mime-types');\n\nconst { Storage } = require('@google-cloud/storage');\nconst multer = require('multer');\n\nconst app = express();\n\nconst storage = new Storage({\n  projectId: process.env.GOOGLE_CLOUD_PROJECT_ID,\n  keyFilename: process.env.GOOGLE_CLOUD_STORAGE_KEYFILE,\n});\n\nconst bucket = storage.bucket(process.env.GOOGLE_CLOUD_STORAGE_BUCKET);\n\nconst upload = multer({\n  // memory storage stores the file in the server's memory until it is uploaded to the cloud storage\n  storage: multer.memoryStorage(),\n  // alternatively you can store in the os temp folder\n  // dest: require('os').tmpdir(),\n});\n\napp.post('/upload', upload.single('file'), async (req, res) =&gt; {\n  const { file } = req;\n\n  if (!file) {\n    return res.status(400).send('No file uploaded.');\n  }\n  const {\n    originalname,\n    mimetype,\n    buffer\n  } = file;\n\n\n  const extension = mime.extension(file.mimetype);\n  cpmst uniqueFileName = `${uuid()}.${extension}`;\n\n  // create a new file in the bucket\n  const fileUpload = bucket.file(uniqueFileName);\n\n  await bucket.upload(buffer, {\n    destination: uniqueFileName,\n    metadata: {\n      contentType: file.mimetype,\n    },\n  });\n\n  // make the file public so it can be accessed publicly via a URL\n  await fileUpload.makePublic();\n\n  // store the path in the user's profile\n  const { user } = req;\n\n  await user.update({ avatar: `/${bucket.name}/${uniqueFileName}` });\n\n  await user.save();\n\n  res.json({ message: 'File uploaded successfully' });\n});\n\napp.listen(3000, () =&gt; {\n  console.log('Server running on port 3000');\n});\n</code></pre>"},{"location":"sprint06/FileUpload/#good-practices-when-storing-files","title":"Good practices when storing files","text":"<p>When storing files in the API, it is also mandatory to consider some good practices to ensure the security and performance of the application. Also we need to avoid users from storing malicious files or too large files that could compromise the server.</p> <p>Some good practices include: - Only authorized users should be able to upload files. - Quota limits should be set for file uploads to prevent abuse. - File types and sizes should be validated before storing them. - File sizes should be limited to prevent denial of service attacks.</p> <p>When using multer and express, you can set file size limits and filter file types using the <code>limits</code> and <code>fileFilter</code> options in the multer configuration.</p> <pre><code>const upload = multer({\n  // any of the previously mentioned storage options\n  storage: multer.memoryStorage(),\n  limits: {+\n    fileSize: 5 * 1024 * 1024, // 5MB limit for example \n  },\n  fileFilter: (req, file, cb) =&gt; {\n    const whitelist = [\n      'image/png',\n      'image/jpeg',\n      'image/jpg',\n      'image/webp'\n    ]\n\n    if (!whitelist.includes(file.mimetype)) {\n      return cb(new Error('Invalid file type'));\n    }\n  },\n});\n</code></pre> <p>Additionally, you can also setup a validation middleware to check if the user has quota limits for file uploads.</p> <pre><code>const maxQuota = 100 * 1024 * 1024; // 100MB for example\n\nconst validateQuota = (req, res, next) =&gt; {\n  const { user } = req;\n  const { file } = req;\n  const { usedQuota } = user;\n\n  if (usedQuota + file.size &gt; maxQuota) {\n    return res.status(400).json({ message: 'Quota limit exceeded' });\n  }\n\n  next();\n};\n</code></pre>"},{"location":"sprint06/FileUpload/#using-a-cdn-to-serve-static-files","title":"Using a CDN to serve static files","text":"<p>When serving static files like images, videos, or documents, it's common to use a Content Delivery Network (CDN) to improve performance and reduce latency.</p> <p>A CDN is a network of servers distributed across different locations that cache static content and deliver it to users based on their geographic location. This helps reduce the load on the origin server and improves the speed at which content is delivered to users.</p> <p>Popular CDN providers include Cloudflare, Akamai, Amazon CloudFront, and Google Cloud CDN.</p> <p>To use a CDN with your web application, you need to configure the CDN to cache your static files and set up the appropriate DNS records to point to the CDN's servers.</p> <p>As the responses from the CDN are cached in a distributed network of servers, the content is delivered faster to users, resulting in a better user experience. It also reduces the load on the origin server, making it more scalable and reliable.</p>"},{"location":"sprint06/FileUpload/#conclusion","title":"Conclusion","text":"<p>In this lesson, we covered the process of uploading files from a client-side application to a server-side API and storing them in a file system. We used Multer as a middleware to handle file uploads in an Express application and generated unique filenames using the <code>uuid</code> package.</p> <p>By following the steps outlined in this lesson, you can implement file uploads in your web application and serve static files using a CDN to improve performance and reduce latency.</p>"}]}